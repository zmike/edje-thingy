/*
 * Copyright 2011 Mike Blumenkrantz <mike@zentific.com>
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published
 * by the Free Software Foundation, either version 2.1 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the 
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */

%name edje_parser_
%token_prefix EDJE_
%token_type {Edje_Token *}
%token_destructor {edje_parser_token_free($$);}
%extra_argument {Edje_Parser *ep}
%syntax_error {ERROR_SYNTAX(TOKEN);}
%stack_overflow {eina_stringshare_replace(&ep->error, "Parser stack overflow!\n");}
%include {
#include "edje_parser_lib.h"
#include "edje.h"
#include "edje_parser.h"
#include "edje_parser_macros.h"
#include <ctype.h>
#include <errno.h>

#define YYCTYPE  char
#define YYCURSOR c
#define YYMARKER q
#define YYCTXMARKER t

#define EDJE_EOF     0
#define EDJE_UNKNOWN (-1)

#define RET(tok) return edje_parser_token_new(s, tok, c - b)

#define NEXT \
       edje_parser_stream_next(s, c - b); \
       b = c

extern void *edje_parser_Alloc(void *(*)(size_t));
extern void  edje_parser_Free(void *, void (*)(void *));
extern void  edje_parser_(void *,
                         int,
                         Edje_Token *,
                         Edje_Parser *);
/* for reference
extern void        edje_parser_Trace(FILE *,
                                    char *);
*/
   static Edje_Token *
   edje_parser_stream_to_token(Edje_Stream *s)
   {
      const char *c, *b, *q;
      //unsigned int cont = 0;

      if (s->length == s->index)
        return edje_parser_token_new(s, EDJE_EOF, 0);

      c = b = s->buffer + s->index;
/*
   FILE  = ([^:\"]?[\040-\176]);
 
   "#define"          { RET(EDJE_DEFINE); }
   "#include"         { RET(EDJE_INCLUDE); }

   "fonts"            { RET(EDJE_FONTS); }
   "data"             { RET(EDJE_DATA); }
   "images"           { RET(EDJE_IMAGES); }
   "styles"           { RET(EDJE_STYLES); }
   "externals"        { RET(EDJE_EXTERNALS); }

   "parts"            { RET(EDJE_PARTS); }
   "part"             { RET(EDJE_PART); }

   

   [-]?[0-9]*[.]?[0-9]* { RET(EDJE_DOUBLE); }

   ":"                { RET(EDJE_COLON); }

   "."                { RET(EDJE_DOT); }
   "\""               { RET(EDJE_QUOTE); }
*/
main:
/*!re2c

   re2c:indent:top       = 2;
   re2c:indent:string    = " ";
   re2c:yyfill:enable    = 0;

   NONPRINT   = [^];
   ENDINPUT   = "\000";
   D     = [-]?[0-9]+;
   N     = [a-z0-9_];

   SLCOM = "\\" (.\ENDINPUT)* ("\n"|ENDINPUT);

   SLCOM              { NEXT; goto main; }
   "/*"               { goto commentblock; }
   [ \t\n\r]+         { NEXT; goto main; }
   "\""[\040-\176]+"\"" { RET(EDJE_ID); }
   ([a-z]N+)":"       { RET(EDJE_PROPERTY); }

   "collections"      { RET(EDJE_COLLECTIONS); }
   "color_classes"    { RET(EDJE_COLOR_CLASSES); }
   "color_class"      { RET(EDJE_COLOR_CLASS); }
   "group"            { RET(EDJE_GROUP); }
   "RAW"              { RET(EDJE_RAW); }
   "COMP"             { RET(EDJE_COMP); }
   "LOSSY"            { RET(EDJE_LOSSY); }
   "USER"             { RET(EDJE_USER); }
   "{"                { RET(EDJE_LB); }
   "}"                { RET(EDJE_RB); }

   D                  { RET(EDJE_INTEGER); }

   ";"                { RET(EDJE_SEMICOLON); }
   ENDINPUT           { RET(EDJE_EOF); }
   NONPRINT           { RET(EDJE_UNKNOWN); }

 */

commentblock:
/*!re2c
   "*/"                { NEXT; goto main; }
  ENDINPUT             { RET(EDJE_UNKNOWN); }
  NONPRINT             { goto commentblock; }
*/

     return NULL;
   }

   Edje *edje_parse_string(const char *str, Eina_Bool *err)
   {
      return edje_parser_string_parse(str, err, edje_parser_, edje_parser_Alloc, edje_parser_Free, edje_parser_stream_to_token);
   }
   Edje *edje_parse_file(const char *path, Eina_Bool *err)
   {
      return edje_parser_file_parse(path, err, edje_parser_, edje_parser_Alloc, edje_parser_Free, edje_parser_stream_to_token);
   }

   /* handle errno more easily */
   static Eina_Bool edje_parser_strtol(const char *text, int *i)
   {
        errno = 0;
        *i = strtol(text, NULL, 10);
        if (errno) return EINA_FALSE;

        return EINA_TRUE;
   }

}

edje ::= toplevel_blocks.

toplevel_blocks ::= toplevel_block.
toplevel_blocks ::= toplevel_blocks toplevel_block.
toplevel_block ::= collection.
{
   EDJE_CREATE;
   EDJE_APPEND(collections, COLLECTION, Edje_Collection);
   COLLECTION = NULL;
}
toplevel_block ::= images.
{
   EDJE_CREATE;
   EDJE_APPEND(images, IMAGES, Edje_Images);
   IMAGES = NULL;
}

/*
toplevel_block ::= externals_block(B).
{
   EDJE_CREATE;
   EDJE_APPEND(externals);
}
toplevel_block ::= sets_block(B).
{
   EDJE_CREATE;
   EDJE_APPEND(sets);
}
toplevel_block ::= fonts_block(B).
{
   EDJE_CREATE;
   EDJE_APPEND(fonts);
}
toplevel_block ::= data_block(B).
{
   EDJE_CREATE;
   EDJE_APPEND(data);
}
toplevel_block ::= styles_block(B).
{
   EDJE_CREATE;
   EDJE_APPEND(styles);
}
*/
toplevel_block ::= color_classes.
{
   EDJE_CREATE;
   EDJE_APPEND(color_classes, COLOR_CLASS, Edje_Color_Class);
   COLOR_CLASS = NULL;
}

%type doc_comment {const char *}
doc_comment(Y) ::= . {Y = NULL;}
doc_comment(Y) ::= DOC(X).
{
   printf("Comment: %s\n", X->text);
   Y = X->text;
   X->text = NULL;
   edje_parser_token_free(X);
}
/******************************* START COLLECTIONS CODE *********************************/
collection ::= collection_start collection_block.
collection_start ::= doc_comment(C) COLLECTIONS.
{
   Edje_Collection *c;
   
   EDJE_CREATE;
   c = edje_collection_new();
   PARSER_APPEND(COLLECTION, c, Edje_Collection);
   printf("Collection: %p\n", c);
   c->doc = C;
}
collection_block ::= LB collections_subblocks RB.
collections_subblocks ::= collections_subblocks collections_subblock.
collections_subblocks ::= collections_subblock.

collections_subblock ::= group.
{
   Edje_Collection *c;
   c = PARSER_CURRENT(COLLECTION, Edje_Collection);
   EDJE_STRUCT_APPEND(c, groups, EINA_INLIST_GET(GROUP), Edje_Group);
   GROUP = NULL;
}
collections_subblock ::= color_classes.
{
   Edje_Collection *c;
   c = PARSER_CURRENT(COLLECTION, Edje_Collection);
   EDJE_STRUCT_APPEND(c, color_classes, EINA_INLIST_GET(COLOR_CLASS), Edje_Color_Class);
   COLOR_CLASS = NULL;
}
/******************************* END COLLECTIONS CODE *********************************/
/******************************* START COLOR_CLASS CODE *********************************/
color_classes ::= color_classes_start color_classes_block.
color_classes_start ::= doc_comment COLOR_CLASSES.
color_classes_block ::= LB color_class RB.

color_class ::= color_class color_class_start color_class_block.
color_class ::= color_class_start color_class_block.
color_class_start ::= doc_comment(C) COLOR_CLASS.
{
   Edje_Color_Class *c;

   c = edje_color_class_new();
   PARSER_APPEND(COLOR_CLASS, c, Edje_Color_Class);
   c->doc = C;
}
color_class_block ::= LB color_class_properties RB.
color_class_properties ::= color_class_properties color_class_property.
color_class_properties ::= color_class_property.
color_class_property ::= PROPERTY ID(I) SEMICOLON.
{
   Edje_Color_Class *c;

   c = PARSER_CURRENT(COLOR_CLASS, Edje_Color_Class);
   printf("Color class name: %s\n", I->text);
   c->name = eina_stringshare_add(I->text);
   edje_parser_token_free(I);
}
color_class_property ::= PROPERTY(P) INTEGER(I) INTEGER(J) INTEGER(K) INTEGER(L) SEMICOLON.
{
   size_t len;
   int *color, i;
   const char *text[4];
   Edje_Color_Class *c;

   c = PARSER_CURRENT(COLOR_CLASS, Edje_Color_Class);

   text[0] = I->text;
   text[1] = J->text;
   text[2] = K->text;
   text[3] = L->text;
   printf("Color class property: %s:%s %s %s %s\n", P->text, I->text, J->text, K->text, L->text);
   len = strlen(P->text); /* check for color*: */
   if ((len < 6) || (len > 7) || (strncmp(P->text, "color", 5)))
     {
        ERROR_SYNTAX(P);
        goto color_class_property_out;
     }
   if ((len == 7) && ((P->text[5] != '2') && (P->text[5] != '3')))
     {
        ERROR_SYNTAX(P);
        goto color_class_property_out;
     }
   if (len == 6) /* color: */
     color = c->color;
   else if (P->text[5] == '2') /* color2: */
     color = c->color2;
   else /* color3: */
     color = c->color3;

   for (i = 0; i < 4; i++)
     {
        if (!edje_parser_strtol(text[i], &color[i]) || (color[i] < 0) || (color[i] > 255))
          {
             switch (i)
               {
                case 0:
                  ERROR_RANGE(I);
                  break;
                case 1:
                  ERROR_RANGE(J);
                  break;
                case 2:
                  ERROR_RANGE(K);
                  break;
                default:
                  ERROR_RANGE(L);
               }
             break;
          }
     }
   
color_class_property_out:
   edje_parser_token_free(P);
   edje_parser_token_free(I);
   edje_parser_token_free(J);
   edje_parser_token_free(K);
   edje_parser_token_free(L);
}
/******************************* END COLOR_CLASS CODE *********************************/
/******************************* START IMAGES CODE *********************************/

images ::= images_start images_blocks.
images_start ::= doc_comment(C) IMAGES.
{
   Edje_Images *i;

   EDJE_CREATE;   
   i = edje_images_new();
   PARSER_APPEND(IMAGES, i, Edje_Images);
   printf("Images: %p\n", i);
   i->doc = C;
}
images_blocks ::= LB images_subblocks RB.
images_subblocks ::= images_subblocks images_subblock.
images_subblocks ::= images_subblock.

images_subblock ::= images_image_start compression SEMICOLON.
{
   Edje_Images *i;

   i = PARSER_CURRENT(IMAGES, Edje_Images);
   EDJE_STRUCT_APPEND(i, set_images, EINA_INLIST_GET(SET_IMAGE), Edje_Set_Image);
   SET_IMAGE = NULL;
}
images_image_start ::= PROPERTY(P) ID(I).
{
   Edje_Set_Image *s;

   if (strcmp(P->text, "image:"))
     {
        ERROR_SYNTAX(P);
        goto images_image_out;
     }
   if (strchr(I->text, ':')) // invalid filename characters
     {
        ERROR_SYNTAX(I);
        goto images_image_out;
     }
   EDJE_CREATE;
   s = edje_set_image_new();
   PARSER_APPEND(SET_IMAGE, s, Edje_Set_Image);
   printf("Set image: %p\n", s);
   s->filename = eina_stringshare_add_length(I->text + 1, strlen(I->text + 1) - 1);

images_image_out:
   edje_parser_token_free(P);
   edje_parser_token_free(I);
}

compression ::= RAW.
{
   Edje_Set_Image *i;

   i = PARSER_CURRENT(SET_IMAGE, Edje_Set_Image);
   i->comp = EDJE_COMPRESSION_TYPE_RAW;
}
compression ::= COMP.
{
   Edje_Set_Image *i;

   i = PARSER_CURRENT(SET_IMAGE, Edje_Set_Image);
   i->comp = EDJE_COMPRESSION_TYPE_COMP;
}
compression ::= LOSSY D(I).
{
   Edje_Set_Image *i;
   int num;

   if (!edje_parser_strtol(I->text, &num) || (num < 0) || (num > 100))
     {
        ERROR_RANGE(I);
        goto compression_out;
     }
   i = PARSER_CURRENT(SET_IMAGE, Edje_Set_Image);
   i->comp = EDJE_COMPRESSION_TYPE_LOSSY;
   i->comp_amount = num;

compression_out:
   edje_parser_token_free(I);
}
compression ::= USER.
{
   Edje_Set_Image *i;

   i = PARSER_CURRENT(SET_IMAGE, Edje_Set_Image);
   i->comp = EDJE_COMPRESSION_TYPE_USER;
}

/******************************* END IMAGES CODE *********************************/
/******************************* START GROUPS CODE *********************************/
%type group {Edje_Group *}
group ::= group_start group_block.
group_start ::= doc_comment(C) GROUP.
{
   Edje_Group *g;

   EDJE_CREATE;   
   g = edje_group_new();
   PARSER_APPEND(GROUP, g, Edje_Group);
   printf("Group: %p\n", g);
   g->doc = C;
}
group_block ::= LB group_subblocks RB.

/*************************** GROUP SUB-BLOCKS ************************************/
group_subblocks ::= group_subblocks group_subblock.
group_subblocks ::= group_subblock.

group_subblock ::= color_classes.
{
   Edje_Group *g;

   g = PARSER_CURRENT(GROUP, Edje_Group);
   EDJE_STRUCT_APPEND(g, color_classes, EINA_INLIST_GET(COLOR_CLASS), Edje_Color_Class);
   COLOR_CLASS = NULL;
}
group_subblock ::= images.
{
   Edje_Group *g;

   g = PARSER_CURRENT(GROUP, Edje_Group);
   EDJE_STRUCT_APPEND(g, images, EINA_INLIST_GET(IMAGES), Edje_Images);
   IMAGES = NULL;
}
group_subblock ::= parts.
{
   Edje_Group *g;

   g = PARSER_CURRENT(GROUP, Edje_Group);
   g->parts = PARTS; /* there can only be one parts{} in a group */
   PARTS = NULL;
}
group_subblock ::= group_property.
/*************************** END GROUP SUB-BLOCKS ********************************/
/*************************** GROUP PROPERTY BLOCKS *******************************/
group_property ::= PROPERTY(P) ID(I) SEMICOLON. /* property: "value"; */
{
   Edje_Group *g;

   g = PARSER_CURRENT(GROUP, Edje_Group);
   printf("Group property - '%s':'%s'\n", P->text, I->text);
   if (!strcmp(P->text, "alias:"))
     g->alias = eina_stringshare_add_length(I->text + 1, strlen(I->text + 1) - 1);
   else if (!strcmp(P->text, "name:"))
     g->name = eina_stringshare_add_length(I->text + 1, strlen(I->text + 1) - 1);
   else
     ERROR_SYNTAX(P);

   edje_parser_token_free(P);
   edje_parser_token_free(I);
}
group_property ::= PROPERTY(P) INTEGER(I) SEMICOLON. /* property: bool */
{
   Edje_Group *g;
   int i;

   g = GROUP;
   printf("Group property - '%s':'%s'\n", P->text, I->text);
   if (strcmp(P->text, "script_only:"))
     {
        ERROR_SYNTAX(P);
        goto group_property_bool_out;
     }
   if (strlen(I->text) > 1)
     {
        ERROR_SYNTAX(I);
        goto group_property_bool_out;
     }

   if (!edje_parser_strtol(I->text, &i) || ((i != 1) && (i != 0)))
     {
        ERROR_RANGE(I);
        goto group_property_bool_out;
     }
   g->script_only = !!i;

group_property_bool_out:
   edje_parser_token_free(P);
   edje_parser_token_free(I);
}

group_property ::= PROPERTY(P) INTEGER(I) INTEGER(J) SEMICOLON. /* property: int int */
{
   Edje_Group *g;

   g = GROUP;
   printf("Property: '%s'\n", P->text);
   if (!strcmp(P->text, "min:"))
     {

        if ((!edje_parser_strtol(I->text, &g->min[0])) || (g->min[0] < 0))
          {
             ERROR_RANGE(I);
             goto group_property_int_out;
          }
        else if ((g->max[0] && (g->max[0] < g->min[0])) || (g->max[1] && (g->max[1] < g->min[1])))
          {
             ep->error = eina_stringshare_printf(
               "Syntax error on line %d column %d: max cannot be smaller than min!\n",
               I->sline + 1, I->scol + 1);
             goto group_property_int_out; 
          }
        if ((!edje_parser_strtol(J->text, &g->min[1])) || (g->min[1] < 0))
          ERROR_RANGE(J);
        else if ((g->max[0] < g->min[0]) || (g->max[1] < g->min[1]))
          {
             ep->error = eina_stringshare_printf(
               "Syntax error on line %d column %d: max cannot be smaller than min!\n",
               J->sline + 1, J->scol + 1);
          }
     }
   else if (!strcmp(P->text, "max:"))
     {
        if ((!edje_parser_strtol(I->text, &g->max[0])) || (g->max[0] < 0))
          {
             ERROR_RANGE(I);
             goto group_property_int_out;
          }
        else if ((g->max[0] < g->min[0]) || (g->max[1] < g->min[1]))
          {
             ep->error = eina_stringshare_printf(
               "Syntax error on line %d column %d: max cannot be smaller than min!\n",
               I->sline + 1, I->scol + 1);
             goto group_property_int_out; 
          }
        if ((!edje_parser_strtol(J->text, &g->max[1])) || (g->max[1] < 1))
          ERROR_RANGE(J);
        else if ((g->max[0] < g->min[0]) || (g->max[1] < g->min[1]))
          {
             ep->error = eina_stringshare_printf(
               "Syntax error on line %d column %d: max cannot be smaller than min!\n",
               J->sline + 1, J->scol + 1);
          }
     }
   else
     ERROR_SYNTAX(P);
     
group_property_int_out:
   edje_parser_token_free(P);
   edje_parser_token_free(I);
}
/*************************** END GROUP PROPERTY BLOCKS ***************************/
/******************************* END GROUPS CODE *********************************/
/******************************* START PARTS CODE ********************************/

parts ::= parts_start parts_block.
parts_start ::= doc_comment(C) PARTS.
{
   Edje_Parts *p;

   EDJE_CREATE;
   p = edje_parts_new();
   PARTS = p; // there can only be one at a time
   printf("Parts: %p\n", p);
   p->doc = C;
}
parts_block ::= LB parts_subblocks RB.
/******************************* PARTS SUB-BLOCKS ********************************/
parts_subblocks ::= parts_subblocks parts_subblock.
parts_subblocks ::= parts_subblock.

parts_subblock ::= parts_property.
parts_property ::= PROPERTY(P) ID(A) ID(B).
{
   const char *b;
   char *a;
   if (strcmp(P->text, "aliases"))
     {
        ERROR_SYNTAX(P);
        goto parts_property_out;
     }

   a = strndupa(A->text + 1, strlen(A->text + 1) - 1);
   b = eina_stringshare_add_length(B->text + 1, strlen(B->text + 1) - 1);

parts_property_out:
   edje_parser_token_free(P);
   edje_parser_token_free(A);
   edje_parser_token_free(B);
}
parts_subblock ::= color_classes.
parts_subblock ::= images.
/*
parts_subblock ::= sets.
parts_subblock ::= fonts.
parts_subblock ::= styles.
parts_subblock ::= part.
parts_subblock ::= programs.
*/
/*************************** END PARTS SUB-BLOCKS *******************************/
/******************************* END PARTS CODE *********************************/
