/*
 * Copyright 2011 Mike Blumenkrantz <mike@zentific.com>
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published
 * by the Free Software Foundation, either version 2.1 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the 
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */

%name edje_parser_
%token_prefix EDJE_
%token_type {Edje_Parser_Token *}
%token_destructor {edje_parser_token_free($$);}
%extra_argument {Edje_Parser *ep}
%syntax_error {ERROR_SYNTAX(TOKEN);}
%stack_size 2000
%stack_overflow {eina_stringshare_replace(&ep->error, "Parser stack overflow!\n");}
%include {
#include "edje_parser_lib.h"
#include "edje.h"
#include "edje_parser.h"
#include "edje_parser_math.h"
#include "edje_parser_macros.h"
#include <ctype.h>
#include <errno.h>

#define YYCTYPE  char
#define YYCURSOR c
#define YYMARKER q
#define YYCTXMARKER t

#define EDJE_EOF     0
#define EDJE_UNKNOWN (-1)

#define RET(tok) return edje_parser_token_new(s, tok, c - b)

#define NEXT \
       edje_parser_stream_next(s, c - b); \
       b = c

extern void *edje_parser_Alloc(void *(*)(size_t));
extern void  edje_parser_Free(void *, void (*)(void *));
extern void  edje_parser_(void *,
                         int,
                         Edje_Parser_Token *,
                         Edje_Parser *);
/* for reference
extern void        edje_parser_Trace(FILE *,
                                    char *);
*/
   static Edje_Parser_Token *
   edje_parser_stream_to_token(Edje_Stream *s)
   {
      const char *c, *b, *q;
      int brace_open = 0, brace_close = 0;

      if (s->length == s->index)
        return edje_parser_token_new(s, EDJE_EOF, 0);

      c = b = s->buffer + s->index;

main:
/*!re2c

   re2c:indent:top       = 2;
   re2c:indent:string    = " ";
   re2c:yyfill:enable    = 0;

   NONPRINT   = [^];
   ENDINPUT   = "\000";
   D     = [-]?[0-9]+;
   N     = [a-z0-9_];
   QUOTED_STR = ("\""[\043-\176 !]*"\"");
   UNQUOTED_STR = ([!\044-\055\057-\071\074-\172|~]+);
   DOUBLE = D?"."[0-9]+;

   SL_COMMENT = "//" (.\ENDINPUT)* ("\n"|ENDINPUT);

   SL_COMMENT         { NEXT; goto main; }
   "/*"("*"*|[^ \t\n\r]*)
{
   while (c++)
     {
        if ((*c == '*') && (c + 1) && (c[1] == '/'))
          {
             c += 2;
             NEXT;
             goto main;
          }
     }
   RET(EDJE_UNKNOWN);
}
   [ \t\n\r]+         { NEXT; goto main; }

   ([a-z]N*)[ \t]*":" { RET(EDJE_PROPERTY); }
   "collections"      { RET(EDJE_COLLECTIONS); }
   "set"              { RET(EDJE_SET); }
   "externals"        { RET(EDJE_EXTERNALS); }
   "data"             { RET(EDJE_DATA); }
   "color_classes"    { RET(EDJE_COLOR_CLASSES); }
   "color_class"      { RET(EDJE_COLOR_CLASS); }
   "images"           { RET(EDJE_IMAGES); }
   "image"            { RET(EDJE_IMAGE); }
   "fill"             { RET(EDJE_FILL); }
   "origin"           { RET(EDJE_ORIGIN); }
   "size"             { RET(EDJE_SIZE); }
   "set"              { RET(EDJE_SET); }
   "dragable"         { RET(EDJE_DRAGABLE); }
   "description"      { RET(EDJE_DESCRIPTION); }
   "fonts"            { RET(EDJE_FONTS); }
   "text"             { RET(EDJE_TEXT); }
   "box"              { RET(EDJE_BOX); }
   "map"              { RET(EDJE_MAP); }
   "rotation"         { RET(EDJE_ROTATION); }
   "perspective"      { RET(EDJE_PERSPECTIVE); }
   "programs"         { RET(EDJE_PROGRAMS); }
   "program"          { RET(EDJE_PROGRAM); }
   "styles"           { RET(EDJE_STYLES); }
   "style"            { RET(EDJE_STYLE); }
   "script"
{
   while (c++)
     {
        if (*c == '{') brace_open++;
        else if (*c == '}') brace_close++;
        if (brace_open && (*c == '}') && (brace_open == brace_close))
          {
             c++;
             RET(EDJE_EMBRYO);
          }
     }
   RET(EDJE_UNKNOWN);
}
   "font:"             { RET(EDJE_FONT); }
   "rel1"             { RET(EDJE_REL1); }
   "rel2"             { RET(EDJE_REL2); }
   "parts"            { RET(EDJE_PARTS); }
   "params"           { RET(EDJE_PARAMS); }
   "part"             { RET(EDJE_PART); }
   "group"            { RET(EDJE_GROUP); }
   "LOSSY"            { RET(EDJE_LOSSY); }

   "{"                { RET(EDJE_LB); }
   "}"";"?            { RET(EDJE_RB); }

   ";"+               { RET(EDJE_SEMICOLON); }
   "."                { RET(EDJE_DOT); }
   (QUOTED_STR)(QUOTED_STR)+ { RET(EDJE_DOUBLEQUOTES); }
   QUOTED_STR|UNQUOTED_STR|((UNQUOTED_STR)?(DOUBLE)(UNQUOTED_STR)?)+ { RET(EDJE_ID); }
   ENDINPUT           { RET(EDJE_EOF); }
   NONPRINT           { RET(EDJE_UNKNOWN); }

 */


     return NULL;
   }

   Edje *edje_parse_string(const char *str, Eina_Bool *err)
   {
      return edje_parser_string_parse(str, err, edje_parser_, edje_parser_Alloc, edje_parser_Free, edje_parser_stream_to_token);
   }
   Edje *edje_parse_file(const char *path, Eina_Bool *err)
   {
      return edje_parser_file_parse(path, err, edje_parser_, edje_parser_Alloc, edje_parser_Free, edje_parser_stream_to_token);
   }
}

edje ::= toplevel_blocks.

toplevel_blocks ::= toplevel_block.
toplevel_blocks ::= toplevel_blocks toplevel_block.
toplevel_block ::= collection.
{
   EDJE_CREATE;
   EDJE_APPEND(collections, COLLECTION, Edje_Collection);
   COLLECTION = NULL;
}
toplevel_block ::= images.
{
   EDJE_CREATE;
   EDJE_APPEND(imageses, IMAGES, Edje_Images);
   IMAGES = NULL;
}
toplevel_block ::= fonts.
{
   EDJE_CREATE;
   EDJE_APPEND(fontses, FONTS, Edje_Fonts);
   FONTS = NULL;
}
toplevel_block ::= externals.
{
   EDJE_CREATE;
   EDJE_APPEND(externals, EXTERNAL, Edje_External);
   EXTERNAL = NULL;
}
toplevel_block ::= data.
{
   EDJE_CREATE;
   EDJE_APPEND(data, DATA, Edje_Data);
   DATA = NULL;
}
toplevel_block ::= styles.
{
   EDJE_CREATE;
   EDJE_APPEND(styles, STYLE, Edje_Style);
   STYLE = NULL;
}
toplevel_block ::= color_classes.
{
   EDJE_CREATE;
   EDJE_APPEND(color_classes, COLOR_CLASS, Edje_Color_Class);
   COLOR_CLASS = NULL;
}

%type doc_comment {const char *}
doc_comment(Y) ::= . {Y = NULL;}
doc_comment(Y) ::= DOC(X).
{
   DBG("Comment: %s", X->text);
   Y = X->text;
   X->text = NULL;
   edje_parser_token_free(X);
}

%type script {const char *}
script(S) ::= EMBRYO(E).
{
   const char *p, *q;

   p = E->text + 7;
   while (p && (isspace(*p) || (*p == '{')))
     p++;
   q = E->text + strlen(E->text) - 1;
   while (q && (isspace(*q) || (*q == '}')))
     q--;

   S = eina_stringshare_add_length(p, q - p + 1);
   DBG("Script:\n%s", S);
   edje_parser_token_free(E);
}
/******************************* START COLLECTIONS CODE *********************************/
collection ::= collection_start collection_block.
collection_start ::= doc_comment(C) COLLECTIONS.
{
   Edje_Collection *c;
   
   EDJE_CREATE;
   c = edje_collection_new();
   PARSER_APPEND(COLLECTION, c, Edje_Collection);
   DBG("Collection: %p", c);
   c->doc = C;
}
collection_block ::= LB collections_subblocks RB.
collection_block ::= LB RB.
collections_subblocks ::= collections_subblocks collections_subblock.
collections_subblocks ::= collections_subblock.

collections_subblock ::= group.
{
   Edje_Collection *c;
   c = PARSER_CURRENT(COLLECTION, Edje_Collection);
   EDJE_STRUCT_APPEND(c, groups, GROUP, Edje_Group);
   GROUP = NULL;
}
collections_subblock ::= set.
{
   Edje_Collection *c;
   c = PARSER_CURRENT(COLLECTION, Edje_Collection);
   EDJE_STRUCT_APPEND(c, sets, SET, Edje_Set);
   SET = NULL;
}
collections_subblock ::= color_classes.
{
   Edje_Collection *c;
   c = PARSER_CURRENT(COLLECTION, Edje_Collection);
   EDJE_STRUCT_APPEND(c, color_classes, COLOR_CLASS, Edje_Color_Class);
   COLOR_CLASS = NULL;
}
collections_subblock ::= images.
{
   Edje_Collection *c;
   c = PARSER_CURRENT(COLLECTION, Edje_Collection);
   EDJE_STRUCT_APPEND(c, imageses, IMAGES, Edje_Images);
   IMAGES = NULL;
}
collections_subblock ::= externals.
{
   Edje_Collection *c;
   c = PARSER_CURRENT(COLLECTION, Edje_Collection);
   EDJE_STRUCT_APPEND(c, externals, EXTERNAL, Edje_External);
   EXTERNAL = NULL;
}
collections_subblock ::= styles.
{
   Edje_Collection *c;
   c = PARSER_CURRENT(COLLECTION, Edje_Collection);
   EDJE_STRUCT_APPEND(c, styles, STYLE, Edje_Style);
   STYLE = NULL;
}
collections_subblock ::= fonts.
{
   Edje_Collection *c;
   c = PARSER_CURRENT(COLLECTION, Edje_Collection);
   EDJE_STRUCT_APPEND(c, fontses, FONTS, Edje_Fonts);
   FONTS = NULL;
}
/******************************* END COLLECTIONS CODE ***********************************/
/******************************** START DATA CODE ***************************************/
data ::= data_start data_block.
data_start ::= doc_comment DATA.
data_block ::= LB data_subblocks RB.
data_block ::= LB RB.
data_block ::= DOT data_subblock.
data_subblocks ::= data_subblocks data_subblock.
data_subblocks ::= data_subblock.

data_subblock ::= PROPERTY(P) ID(I) ID(J) SEMICOLON.
{
   Edje_Data *d;

   if (!edje_parser_property_check(P->text, "item"))
     {
        d = edje_data_new();
        eina_hash_add(d->items, STRDUPA_NOQUOTES(I->text), STRINGSHARE_ADD_NOQUOTES(J->text));
        PARSER_APPEND(DATA, d, Edje_Data);
     }
   else if (!edje_parser_property_check(P->text, "file"))
     {
        d = edje_data_new();
        eina_hash_add(d->files, STRDUPA_NOQUOTES(I->text), STRINGSHARE_ADD_NOQUOTES(J->text));
        PARSER_APPEND(DATA, d, Edje_Data);
     }
   else ERROR_SYNTAX(P);

   edje_parser_token_free(P);
   edje_parser_token_free(I);
   edje_parser_token_free(J);
}
/********************************* END DATA CODE ****************************************/
/******************************** START STYLES CODE *************************************/
styles ::= STYLES LB styles_blocks RB.
styles ::= STYLES LB RB.
styles ::= STYLES DOT styles_block.
styles_blocks ::= styles_blocks styles_block.
styles_blocks ::= styles_block.
styles_block ::= style.

style ::= style_start style_block.
style_start ::= doc_comment(C) STYLE.
{
   Edje_Style *s;

   EDJE_CREATE;
   s = edje_style_new();
   PARSER_APPEND(STYLE, s, Edje_Style);
   DBG("Style: %p", s);
   s->doc = C;
}
style_block ::= LB style_subblocks RB.
style_block ::= LB RB.
style_block ::= DOT style_subblock.
style_subblocks ::= style_subblocks style_subblock.
style_subblocks ::= style_subblock.
style_subblock ::= PROPERTY(P) ID(I) SEMICOLON.
{
   Edje_Style *s;

   s = PARSER_CURRENT(STYLE, Edje_Style);
   if (!edje_parser_property_check(P->text, "name") && (!s->name))
     STRINGSHARE_REPLACE_NOQUOTES(s->name, I->text);
   else if (!edje_parser_property_check(P->text, "base") && (!s->base))
     STRINGSHARE_REPLACE_NOQUOTES(s->base, I->text);
   else ERROR_SYNTAX(P);

   edje_parser_token_free(P);
   edje_parser_token_free(I);
}
style_subblock ::= PROPERTY(P) ID(I) ID(J) SEMICOLON.
{
   Edje_Style *s;

   s = PARSER_CURRENT(STYLE, Edje_Style);
   if (!edje_parser_property_check(P->text, "tag"))
     eina_hash_add(s->tags, STRDUPA_NOQUOTES(I->text),
       STRINGSHARE_ADD_NOQUOTES(J->text));
   else ERROR_SYNTAX(P);

   edje_parser_token_free(P);
   edje_parser_token_free(I);
   edje_parser_token_free(J);
}
/********************************* END STYLES CODE **************************************/
/******************************** START SET CODE ****************************************/
set ::= set_start set_block.
set_start ::= doc_comment(C) SET.
{
   Edje_Set *s;

   EDJE_CREATE;
   s = edje_set_new();
   PARSER_APPEND(SET, s, Edje_Set);
   DBG("Set: %p", s);
   s->doc = C;
}
set_block ::= LB set_subblocks RB.
set_block ::= LB RB.
set_block ::= DOT set_subblock.
set_subblocks ::= set_subblocks set_subblock.
set_subblocks ::= set_subblock.

set_subblock ::= PROPERTY(P) ID(I) SEMICOLON.
{
   Edje_Set *s;

   if (!edje_parser_property_check(P->text, "name"))
     STRINGSHARE_REPLACE_NOQUOTES(s->name, I->text);
   else ERROR_SYNTAX(P);

   edje_parser_token_free(P);
   edje_parser_token_free(I);
}
set_subblock ::= set_image.
set_image ::= set_image_start set_image_block.
set_image_start ::= doc_comment(C) IMAGE.
{
   Edje_Set_Image *s;

   s = edje_set_image_new();
   PARSER_APPEND(SET_IMAGE, s, Edje_Set_Image);
   DBG("Set_Image: %p", s);
   s->doc = C;
}
set_image_block ::= LB set_image_subblocks RB.
set_image_block ::= LB RB.
set_image_block ::= DOT set_image_subblock.
set_image_subblocks ::= set_image_subblock set_image_subblock.
set_image_subblocks ::= set_image_subblock.
set_image_subblock ::= images_image.
set_image_subblock ::= PROPERTY(P) ID(I) SEMICOLON.
{
   if (!edje_parser_property_check(P->text, "image"))
     {
        if (strchr(I->text, ':')) // invalid filename characters
          ERROR_SYNTAX(I);
        else
          {
             Edje_Set_Image *s;
             s = PARSER_CURRENT(SET_IMAGE, Edje_Set_Image);
             if ((!s) || (s->filename))
               { /* play nice with Edje_Set objects */
                  s = edje_set_image_new();
                  PARSER_APPEND(SET_IMAGE, s, Edje_Set_Image);
                  DBG("Set image: %p", s);
               }
             STRINGSHARE_REPLACE_NOQUOTES(s->filename, I->text);
             s->comp = EDJE_COMPRESSION_TYPE_COMP;
          }
     }
   else ERROR_SYNTAX(P);

   edje_parser_token_free(P);
   edje_parser_token_free(I);
}
set_image_subblock ::= PROPERTY(P) ID(I) ID(J) ID(K) ID(L) SEMICOLON.
{
   Edje_Set_Image *s;
   Edje_Parser_Token *t[4];
   unsigned int i;

   t[0] = I;
   t[1] = J;
   t[2] = K;
   t[3] = L;

   s = PARSER_CURRENT(SET_IMAGE, Edje_Set_Image);

   for (i = 0; i < 4; i++)
     {
        if (!edje_parser_strtol(t[i]->text, &s->size[i]))
          {
             ERROR_RANGE(t[i]);
             break;
          }
     }
     
   edje_parser_token_free(P);
   edje_parser_token_free(I);
   edje_parser_token_free(J);
   edje_parser_token_free(K);
   edje_parser_token_free(L);
}
/********************************* END SET CODE ****************************************/
/******************************* START EXTERNALS CODE ***********************************/
externals ::= externals_start externals_block.
externals_start ::= doc_comment EXTERNALS.
externals_block ::= LB externals_subblocks RB.
externals_block ::= LB RB.
externals_block ::= DOT externals_subblock.
externals_subblocks ::= externals_subblocks externals_subblock.
externals_subblocks ::= externals_subblock.

externals_subblock ::= PROPERTY(P) ID(I) SEMICOLON.
{
   Edje_External *e;

   if (!edje_parser_property_check(P->text, "external"))
     {
        e = edje_external_new();
        STRINGSHARE_REPLACE_NOQUOTES(e->external, I->text);
        PARSER_APPEND(EXTERNAL, e, Edje_External);
     }
   else ERROR_SYNTAX(P);

   edje_parser_token_free(P);
   edje_parser_token_free(I);
}
/******************************* END EXTERNALS CODE *****************************************/
/******************************* START FONTS CODE ***************************************/
fonts ::= fonts_start fonts_block.
fonts_start ::= doc_comment(C) FONTS.
{
   Edje_Fonts *f;

   EDJE_CREATE;
   f = edje_fonts_new();
   PARSER_APPEND(FONTS, f, Edje_Fonts);
   DBG("Fonts: %p", f);
   f->doc = C;
}
fonts_block ::= LB fonts_subblocks RB.
fonts_block ::= LB RB.
fonts_block ::= DOT fonts_subblock.
fonts_subblocks ::= fonts_subblocks fonts_subblock.
fonts_subblocks ::= fonts_subblock.

fonts_subblock ::= font.
{
   Edje_Fonts *f;

   f = PARSER_CURRENT(FONTS, Edje_Fonts);
   EDJE_STRUCT_APPEND(f, fonts, FONT, Edje_Font);
   FONT = NULL;
}
/******************************* END FONTS CODE *****************************************/
/******************************* START FONT CODE ****************************************/
font ::= doc_comment(C) FONT ID(I) ID(J) SEMICOLON.
{
   Edje_Font *f;

   f = edje_font_new();
   PARSER_APPEND(FONT, f, Edje_Font);
   DBG("Font: %p", f);
   f->doc = C;

   STRINGSHARE_REPLACE_NOQUOTES(f->name, I->text);
   STRINGSHARE_REPLACE_NOQUOTES(f->alias, J->text);

   edje_parser_token_free(I);
   edje_parser_token_free(J);
}
/******************************* END FONT CODE ******************************************/
/******************************* START COLOR_CLASS CODE *********************************/
color_classes ::= color_classes_start color_classes_block.
color_classes_start ::= doc_comment COLOR_CLASSES.
color_classes_block ::= LB color_class RB.
color_classes_block ::= LB RB.

color_class ::= color_class color_class_start color_class_block.
color_class ::= color_class_start color_class_block.
color_class_start ::= doc_comment(C) COLOR_CLASS.
{
   Edje_Color_Class *c;

   c = edje_color_class_new();
   PARSER_APPEND(COLOR_CLASS, c, Edje_Color_Class);
   c->doc = C;
}
color_class_block ::= LB color_class_properties RB.
color_class_block ::= LB RB.
color_class_properties ::= color_class_properties color_class_property.
color_class_properties ::= color_class_property.
color_class_property ::= PROPERTY ID(I) SEMICOLON.
{
   Edje_Color_Class *c;

   c = PARSER_CURRENT(COLOR_CLASS, Edje_Color_Class);
   DBG("Color class name: %s", I->text);
   c->name = eina_stringshare_add(I->text);
   edje_parser_token_free(I);
}
color_class_property ::= PROPERTY(P) ID(I) ID(J) ID(K) ID(L) SEMICOLON.
{

   Edje_Color_Class *c;
   int *colors[3];
   Edje_Parser_Token *tokens[4];

   c = PARSER_CURRENT(COLOR_CLASS, Edje_Color_Class);

   tokens[0] = I;
   tokens[1] = J;
   tokens[2] = K;
   tokens[3] = L;
   colors[0] = c->color;
   colors[1] = c->color2;
   colors[2] = c->color3;
   if (!edje_parser_parse_color(ep, P, (Edje_Parser_Token**)tokens, (int**)colors) && (!ep->error))
     ERROR_SYNTAX(P);

   edje_parser_token_free(P);
   edje_parser_token_free(I);
   edje_parser_token_free(J);
   edje_parser_token_free(K);
   edje_parser_token_free(L);
}
/******************************* END COLOR_CLASS CODE *********************************/
/******************************* START PROGRAMS CODE **********************************/
programs ::= programs_start programs_blocks.
programs_start ::= doc_comment(C) PROGRAMS.
{
   Edje_Programs *p;

   EDJE_CREATE;   
   p = edje_programs_new();
   PARSER_APPEND(PROGRAMS, p, Edje_Programs);
   DBG("Programs: %p", p);
   p->doc = C;
}
programs_blocks ::= LB programs_subblocks RB.
programs_blocks ::= LB RB.
programs_blocks ::= DOT programs_subblock.
programs_subblocks ::= programs_subblocks programs_subblock.
programs_subblocks ::= programs_subblock.

programs_subblock ::= program.
{
   Edje_Programs *p;

   p = PARSER_CURRENT(PROGRAMS, Edje_Programs);
   EDJE_STRUCT_APPEND(p, programs, PROGRAM, Edje_Program);
   PROGRAM = NULL;
}
programs_subblock ::= PROPERTY(P) ID(I) SEMICOLON.
{
   if (!edje_parser_property_check(P->text, "image"))
     {
        if (strchr(I->text, ':')) // invalid filename characters
          ERROR_SYNTAX(I);
        else
          {
             Edje_Set_Image *s;
             Edje_Programs *p;

             p = PARSER_CURRENT(PROGRAMS, Edje_Programs);
             s = PARSER_CURRENT(SET_IMAGE, Edje_Set_Image);
             if ((!s) || (s->filename))
               { /* play nice with Edje_Set objects */
                  s = edje_set_image_new();
                  PARSER_APPEND(SET_IMAGE, s, Edje_Set_Image);
                  DBG("Set image: %p", s);
               }
             STRINGSHARE_REPLACE_NOQUOTES(s->filename, I->text);
             s->comp = EDJE_COMPRESSION_TYPE_COMP;
             EDJE_STRUCT_APPEND(p, images, SET_IMAGE, Edje_Set_Image);
             SET_IMAGE = NULL;
          }
     }
   else ERROR_SYNTAX(P);

   edje_parser_token_free(P);
   edje_parser_token_free(I);
}
programs_subblock ::= images_image.
{
   Edje_Programs *p;

   p = PARSER_CURRENT(PROGRAMS, Edje_Programs);
   EDJE_STRUCT_APPEND(p, images, SET_IMAGE, Edje_Set_Image);
   SET_IMAGE = NULL;
}
programs_subblock ::= images.
{
   Edje_Programs *p;

   p = PARSER_CURRENT(PROGRAMS, Edje_Programs);
   EDJE_STRUCT_APPEND(p, imageses, IMAGES, Edje_Images);
   IMAGES = NULL;
}
programs_subblock ::= font.
{
   Edje_Programs *p;

   p = PARSER_CURRENT(PROGRAMS, Edje_Programs);
   EDJE_STRUCT_APPEND(p, fonts, FONT, Edje_Font);
   FONT = NULL;
}
programs_subblock ::= fonts.
{
   Edje_Programs *p;

   p = PARSER_CURRENT(PROGRAMS, Edje_Programs);
   EDJE_STRUCT_APPEND(p, fontses, FONTS, Edje_Fonts);
   FONTS = NULL;
}
programs_subblock ::= set.
{
   Edje_Programs *p;

   p = PARSER_CURRENT(PROGRAMS, Edje_Programs);
   EDJE_STRUCT_APPEND(p, sets, SET, Edje_Set);
   SET = NULL;

}
/******************************** END PROGRAMS CODE **********************************/
/******************************** START PROGRAM CODE **********************************/
program ::= program_start program_blocks.
program_start ::= doc_comment(C) PROGRAM.
{
   Edje_Program *p;

   EDJE_CREATE;   
   p = edje_program_new();
   PARSER_APPEND(PROGRAM, p, Edje_Program);
   DBG("Program: %p", p);
   p->doc = C;
}
program_blocks ::= LB program_subblocks RB.
program_blocks ::= LB RB.
program_blocks ::= DOT program_subblock.
program_subblocks ::= program_subblocks program_subblock.
program_subblocks ::= program_subblock.

program_subblock ::= script(S).
{
   Edje_Program *p;

   p = PARSER_CURRENT(PROGRAM, Edje_Program);
   p->script = S;
}

program_subblock ::= PROPERTY(P) ID(I) SEMICOLON.
{
   Edje_Program *p;

   p = PARSER_CURRENT(PROGRAM, Edje_Program);
   if (!edje_parser_property_check(P->text, "name"))
     STRINGSHARE_REPLACE_NOQUOTES(p->name, I->text);
   else if (!edje_parser_property_check(P->text, "signal"))
     STRINGSHARE_REPLACE_NOQUOTES(p->signal, I->text);
   else if (!edje_parser_property_check(P->text, "source"))
     STRINGSHARE_REPLACE_NOQUOTES(p->source, I->text);
   else if (!edje_parser_property_check(P->text, "target"))
     p->targets = eina_list_append(p->targets, STRINGSHARE_ADD_NOQUOTES(I->text));
   else if (!edje_parser_property_check(P->text, "after"))
     p->targets = eina_list_append(p->after, STRINGSHARE_ADD_NOQUOTES(I->text));
   else if (!edje_parser_property_check(P->text, "action") && (!p->action.type))
     {
         if (!strcmp(I->text, "ACTION_STOP"))
           p->action.type = EDJE_PROGRAM_ACTION_ACTION_STOP;
         else if (!strcmp(I->text, "FOCUS_SET"))
           p->action.type = EDJE_PROGRAM_ACTION_FOCUS_SET;
         else if (!strcmp(I->text, "FOCUS_OBJECT"))
           p->action.type = EDJE_PROGRAM_ACTION_FOCUS_OBJECT;
         else ERROR_SYNTAX(I);
     }
   else ERROR_SYNTAX(P);
   edje_parser_token_free(P);
   edje_parser_token_free(I);
}
program_subblock ::= PROPERTY(P) ID(I) ID(J) SEMICOLON.
{
   Edje_Program *p;

   p = PARSER_CURRENT(PROGRAM, Edje_Program);
   if (!edje_parser_property_check(P->text, "api"))
     {
        STRINGSHARE_REPLACE_NOQUOTES(p->api.name, I->text);
        STRINGSHARE_REPLACE_NOQUOTES(p->api.description, J->text);
     }
   else if (!edje_parser_property_check(P->text, "filter"))
     {
        STRINGSHARE_REPLACE_NOQUOTES(p->filter.part, I->text);
        STRINGSHARE_REPLACE_NOQUOTES(p->filter.state, J->text);
     }
   else if (!edje_parser_property_check(P->text, "in"))
     {
        if (!edje_parser_strtod(I->text, &p->in.from) || (p->in.from < 0.0))
          ERROR_RANGE(I);
        else if (!edje_parser_strtod(J->text, &p->in.range) || (p->in.range < 0.0))
          ERROR_RANGE(J);
     }
   else if (!edje_parser_property_check(P->text, "transition") && (!p->action.transition.length) && (!p->action.transition.type)) /* error on double set */
     {
#define EDJE_ACTION_CHECK(NAME) \
  if (!strcmp(I->text, #NAME)) \
    p->action.transition.type = EDJE_PROGRAM_TRANSITION_##NAME

        EDJE_ACTION_CHECK(LINEAR);
        else EDJE_ACTION_CHECK(SINUSOIDAL);
        else EDJE_ACTION_CHECK(ACCELERATE);
        else EDJE_ACTION_CHECK(DECELERATE);
        
        if (!p->action.transition.type)
          ERROR_SYNTAX(I);
        else if (!edje_parser_strtod(J->text, &p->action.transition.length))
          ERROR_RANGE(I);
#undef EDJE_ACTION_CHECK
     }
   else ERROR_SYNTAX(P);
   edje_parser_token_free(P);
   edje_parser_token_free(I);
   edje_parser_token_free(J);
}
program_subblock ::= PROPERTY(P) ID(I) ID(J) ID(K) SEMICOLON.
{
   Edje_Program *p;

   p = PARSER_CURRENT(PROGRAM, Edje_Program);
   if (!edje_parser_property_check(P->text, "action") && (!p->action.type))
     {
         if (!strcmp(I->text, "DRAG_VAL_SET"))
           {
              p->action.type = EDJE_PROGRAM_ACTION_DRAG_VAL_SET;
              if (!edje_parser_strtod(J->text, &p->action.params.numbers[0]))
                ERROR_RANGE(J);
              else if (!edje_parser_strtod(K->text, &p->action.params.numbers[1]))
                ERROR_RANGE(K);
           }
         else if (!strcmp(I->text, "DRAG_VAL_STEP"))
           {
              p->action.type = EDJE_PROGRAM_ACTION_DRAG_VAL_STEP;
              if (!edje_parser_strtod(J->text, &p->action.params.numbers[0]))
                ERROR_RANGE(J);
              else if (!edje_parser_strtod(K->text, &p->action.params.numbers[1]))
                ERROR_RANGE(K);
           }
         else if (!strcmp(I->text, "DRAG_VAL_PAGE"))
           {
              p->action.type = EDJE_PROGRAM_ACTION_DRAG_VAL_PAGE;
              if (!edje_parser_strtod(J->text, &p->action.params.numbers[0]))
                ERROR_RANGE(J);
              else if (!edje_parser_strtod(K->text, &p->action.params.numbers[1]))
                ERROR_RANGE(K);
           }
         else if (!strcmp(I->text, "STATE_SET"))
           {
              p->action.type = EDJE_PROGRAM_ACTION_STATE_SET;
              if (!edje_parser_strtod(K->text, &p->action.params.numbers[0]))
                ERROR_RANGE(K);
              else
                p->action.params.strings =
                  eina_list_append(p->action.params.strings, STRINGSHARE_ADD_NOQUOTES(J->text));
           }
         else if (!strcmp(I->text, "SIGNAL_EMIT"))
           {
              p->action.type = EDJE_PROGRAM_ACTION_SIGNAL_EMIT;
              p->action.params.strings =
                eina_list_append(p->action.params.strings, STRINGSHARE_ADD_NOQUOTES(J->text));
              p->action.params.strings =
                eina_list_append(p->action.params.strings, STRINGSHARE_ADD_NOQUOTES(K->text));  
           }
         else ERROR_SYNTAX(I);
     }
   else ERROR_SYNTAX(P);
   edje_parser_token_free(P);
   edje_parser_token_free(I);
   edje_parser_token_free(J);
   edje_parser_token_free(K);
}
program_subblock ::= PROPERTY(P) ID(C) ID(I) ID(J) ID(K) SEMICOLON.
{
   Edje_Program *p;

   p = PARSER_CURRENT(PROGRAM, Edje_Program);
   if (!edje_parser_property_check(P->text, "action") && (!p->action.type))
     {
         if (!strcmp(C->text, "PARAM_SET"))
           p->action.type = EDJE_PROGRAM_ACTION_PARAM_SET;

         if (!p->action.type) ERROR_SYNTAX(C);
         else
           {
              p->action.params.strings =
                eina_list_append(p->action.params.strings,
                  STRINGSHARE_ADD_NOQUOTES(I->text)
                );
              p->action.params.strings =
                eina_list_append(p->action.params.strings,
                  STRINGSHARE_ADD_NOQUOTES(J->text)
                );
              p->action.params.strings =
                eina_list_append(p->action.params.strings,
                  STRINGSHARE_ADD_NOQUOTES(K->text)
                );
           }
     }
   else ERROR_SYNTAX(P);
   edje_parser_token_free(P);
   edje_parser_token_free(C);
   edje_parser_token_free(I);
   edje_parser_token_free(J);
   edje_parser_token_free(K);
}
program_subblock ::= PROPERTY(P) ID(C) ID(I) ID(J) ID(K) ID(L) SEMICOLON.
{
   Edje_Program *p;

   p = PARSER_CURRENT(PROGRAM, Edje_Program);
   if (!edje_parser_property_check(P->text, "action") && (!p->action.type))
     {
         if (!strcmp(C->text, "PARAM_COPY"))
           p->action.type = EDJE_PROGRAM_ACTION_PARAM_COPY;

         if (!p->action.type) ERROR_SYNTAX(C);
         else
           {
              p->action.params.strings =
                eina_list_append(p->action.params.strings, STRINGSHARE_ADD_NOQUOTES(I->text));
              p->action.params.strings =
                eina_list_append(p->action.params.strings, STRINGSHARE_ADD_NOQUOTES(J->text));
              p->action.params.strings =
                eina_list_append(p->action.params.strings, STRINGSHARE_ADD_NOQUOTES(K->text));
              p->action.params.strings =
                eina_list_append(p->action.params.strings, STRINGSHARE_ADD_NOQUOTES(L->text));
           }
     }
   else ERROR_SYNTAX(P);
   edje_parser_token_free(P);
   edje_parser_token_free(C);
   edje_parser_token_free(I);
   edje_parser_token_free(J);
   edje_parser_token_free(K);
   edje_parser_token_free(L);
}
/******************************** END PROGRAM CODE **********************************/
/******************************* START IMAGES CODE *********************************/

images ::= images_start images_blocks.
images_start ::= doc_comment(C) IMAGES.
{
   Edje_Images *i;

   EDJE_CREATE;   
   i = edje_images_new();
   PARSER_APPEND(IMAGES, i, Edje_Images);
   DBG("Images: %p", i);
   i->doc = C;
}
images_blocks ::= LB images_subblocks RB.
images_blocks ::= LB RB.
images_blocks ::= DOT images_subblock.
images_subblocks ::= images_subblocks images_subblock.
images_subblocks ::= images_subblock.

images_subblock ::= images_image.
{
   Edje_Images *i;

   i = PARSER_CURRENT(IMAGES, Edje_Images);
   EDJE_STRUCT_APPEND(i, images, SET_IMAGE, Edje_Set_Image);
   SET_IMAGE = NULL;
}
images_subblock ::= set.
{
   Edje_Images *i;

   i = PARSER_CURRENT(IMAGES, Edje_Images);
   EDJE_STRUCT_APPEND(i, sets, SET, Edje_Set);
   SET = NULL;
}

images_subblock ::= PROPERTY(P) ID(I) SEMICOLON.
{
   if (!edje_parser_property_check(P->text, "image"))
     {
        if (strchr(I->text, ':')) // invalid filename characters
          ERROR_SYNTAX(I);
        else
          {
             Edje_Set_Image *s;
             Edje_Images *i;

             i = PARSER_CURRENT(IMAGES, Edje_Images);
             s = PARSER_CURRENT(SET_IMAGE, Edje_Set_Image);
             if ((!s) || (s->filename))
               { /* play nice with Edje_Set objects */
                  s = edje_set_image_new();
                  PARSER_APPEND(SET_IMAGE, s, Edje_Set_Image);
                  DBG("Set image: %p", s);
               }
             STRINGSHARE_REPLACE_NOQUOTES(s->filename, I->text);
             s->comp = EDJE_COMPRESSION_TYPE_COMP;
             EDJE_STRUCT_APPEND(i, images, SET_IMAGE, Edje_Set_Image);
             SET_IMAGE = NULL;
          }
     }
   else ERROR_SYNTAX(P);

   edje_parser_token_free(P);
   edje_parser_token_free(I);
}

images_image ::= PROPERTY(P) ID(I) ID(J) SEMICOLON.
{
   if (!edje_parser_property_check(P->text, "image"))
     {
        if (strchr(I->text, ':')) // invalid filename characters
          ERROR_SYNTAX(I);
        else
          {
             Edje_Set_Image *s;
             s = PARSER_CURRENT(SET_IMAGE, Edje_Set_Image);
             if ((!s) || (s->filename))
               { /* play nice with Edje_Set objects */
                  s = edje_set_image_new();
                  PARSER_APPEND(SET_IMAGE, s, Edje_Set_Image);
                  DBG("Set image: %p", s);
               }
             STRINGSHARE_REPLACE_NOQUOTES(s->filename, I->text);
             if (!strcmp(J->text, "RAW"))
               s->comp = EDJE_COMPRESSION_TYPE_RAW;
             else if (!strcmp(J->text, "COMP"))
               s->comp = EDJE_COMPRESSION_TYPE_COMP;
             else if (!strcmp(J->text, "USER"))
               s->comp = EDJE_COMPRESSION_TYPE_USER;
          }
     }
   else ERROR_SYNTAX(P);

   edje_parser_token_free(P);
   edje_parser_token_free(I);
   edje_parser_token_free(J);
}
images_image ::= PROPERTY(P) ID(I) LOSSY ID(J) SEMICOLON.
{
   if (!edje_parser_property_check(P->text, "image"))
     {
        if (strchr(I->text, ':')) // invalid filename characters
          ERROR_SYNTAX(I);
        else
          {
             Edje_Set_Image *s;
             int num;

             s = PARSER_CURRENT(SET_IMAGE, Edje_Set_Image);
             if ((!s) || (s->filename))
               { /* play nice with Edje_Set objects */
                  s = edje_set_image_new();
                  PARSER_APPEND(SET_IMAGE, s, Edje_Set_Image);
                  DBG("Set image: %p", s);
               }
             STRINGSHARE_REPLACE_NOQUOTES(s->filename, I->text);
             if (strchr(J->text, '.') || (!edje_parser_strtol(J->text, &num)) || (num < 0) || (num > 100))
               ERROR_RANGE(J);
             else
               {
                  s->comp = EDJE_COMPRESSION_TYPE_LOSSY;
                  s->comp_amount = num;
               }
          }
     }

   edje_parser_token_free(P);
   edje_parser_token_free(I);
   edje_parser_token_free(J);
}

/******************************* END IMAGES CODE *********************************/
/******************************* START GROUPS CODE *********************************/
%type group {Edje_Group *}
group ::= group_start group_block.
group_start ::= doc_comment(C) GROUP.
{
   Edje_Group *g;

   EDJE_CREATE;   
   g = edje_group_new();
   PARSER_APPEND(GROUP, g, Edje_Group);
   DBG("Group: %p", g);
   g->doc = C;
}
group_block ::= LB group_subblocks RB.
group_block ::= LB RB.
group_block ::= DOT group_subblock.

/*************************** GROUP SUB-BLOCKS ************************************/
group_subblocks ::= group_subblocks group_subblock.
group_subblocks ::= group_subblock.

group_subblock ::= color_classes.
{
   Edje_Group *g;

   g = PARSER_CURRENT(GROUP, Edje_Group);
   EDJE_STRUCT_APPEND(g, color_classes, COLOR_CLASS, Edje_Color_Class);
   COLOR_CLASS = NULL;
}
group_subblock ::= images.
{
   Edje_Group *g;

   g = PARSER_CURRENT(GROUP, Edje_Group);
   EDJE_STRUCT_APPEND(g, imageses, IMAGES, Edje_Images);
   IMAGES = NULL;
}
group_subblock ::= set.
{
   Edje_Group *g;

   g = PARSER_CURRENT(GROUP, Edje_Group);
   EDJE_STRUCT_APPEND(g, sets, SET, Edje_Set);
   SET = NULL;
}
group_subblock ::= fonts.
{
   Edje_Group *g;

   g = PARSER_CURRENT(GROUP, Edje_Group);
   EDJE_STRUCT_APPEND(g, fontses, FONTS, Edje_Fonts);
   FONTS = NULL;
}
group_subblock ::= font.
{
   Edje_Group *g;

   g = PARSER_CURRENT(GROUP, Edje_Group);
   EDJE_STRUCT_APPEND(g, fonts, FONT, Edje_Font);
   FONT = NULL;
}
group_subblock ::= programs.
{
   Edje_Group *g;

   g = PARSER_CURRENT(GROUP, Edje_Group);
   EDJE_STRUCT_APPEND(g, programses, PROGRAMS, Edje_Programs);
   PROGRAMS = NULL;
}
group_subblock ::= program.
{
   Edje_Group *g;

   g = PARSER_CURRENT(GROUP, Edje_Group);
   EDJE_STRUCT_APPEND(g, programs, PROGRAM, Edje_Program);
   PROGRAM = NULL;
}
group_subblock ::= externals.
{
   Edje_Group *g;

   g = PARSER_CURRENT(GROUP, Edje_Group);
   EDJE_STRUCT_APPEND(g, externals, EXTERNAL, Edje_External);
   EXTERNAL = NULL;
}
group_subblock ::= data.
{
   Edje_Group *g;

   g = PARSER_CURRENT(GROUP, Edje_Group);
   EDJE_STRUCT_APPEND(g, data, DATA, Edje_Data);
   DATA = NULL;
}
group_subblock ::= styles.
{
   Edje_Group *g;

   g = PARSER_CURRENT(GROUP, Edje_Group);
   EDJE_STRUCT_APPEND(g, styles, STYLE, Edje_Style);
   STYLE = NULL;
}
group_subblock ::= script(S).
{
   Edje_Group *g;

   g = PARSER_CURRENT(GROUP, Edje_Group);
   g->script = S;
}
group_subblock ::= parts.
{
   Edje_Group *g;

   g = PARSER_CURRENT(GROUP, Edje_Group);
   g->parts = PARTS; /* there can only be one parts{} in a group */
   PARTS = NULL;
}

group_subblock ::= group_property.
/*************************** END GROUP SUB-BLOCKS ********************************/
/*************************** GROUP PROPERTY BLOCKS *******************************/
group_property ::= PROPERTY(P) ID(I) SEMICOLON. /* property: "value"; */
{
   Edje_Group *g;

   g = PARSER_CURRENT(GROUP, Edje_Group);
   if (!edje_parser_property_check(P->text, "alias"))
     STRINGSHARE_REPLACE_NOQUOTES(g->alias, I->text);
   else if (!edje_parser_property_check(P->text, "name"))
     STRINGSHARE_REPLACE_NOQUOTES(g->name, I->text);
   else if (!edje_parser_property_check(P->text, "script_only"))
     {
        int i;
        if (!edje_parser_strtobool(I->text, &i))
          ERROR_RANGE(I);
        else
          g->script_only = !!i;
     }

   else
     ERROR_SYNTAX(P);

   edje_parser_token_free(P);
   edje_parser_token_free(I);
}
group_property ::= PROPERTY(P) ID(I) ID(J) SEMICOLON. /* property: int int */
{
   Edje_Group *g;

   g = PARSER_CURRENT(GROUP, Edje_Group);
   if (!edje_parser_property_check(P->text, "min"))
     {
        if (!edje_parser_parse_min(ep, I, J, g->min, g->max))
          goto group_property_int_out;
     }
   else if (!edje_parser_property_check(P->text, "max"))
     {
        if (!edje_parser_parse_max(ep, I, J, g->min, g->max))
          goto group_property_int_out;
     }
   else
     ERROR_SYNTAX(P);
     
group_property_int_out:
   edje_parser_token_free(P);
   edje_parser_token_free(I);
   edje_parser_token_free(J);
}
/*************************** END GROUP PROPERTY BLOCKS ***************************/
/******************************* END GROUPS CODE *********************************/
/******************************* START PARTS CODE ********************************/
parts ::= parts_start parts_block.
parts_start ::= doc_comment(C) PARTS.
{
   Edje_Parts *p;

   EDJE_CREATE;
   p = edje_parts_new();
   PARTS = p; // there can only be one at a time
   DBG("Parts: %p", p);
   p->doc = C;
}
parts_block ::= LB parts_subblocks RB.
parts_block ::= LB RB.
/******************************* PARTS SUB-BLOCKS ********************************/
parts_subblocks ::= parts_subblocks parts_subblock.
parts_subblocks ::= parts_subblock.

parts_subblock ::= fonts.
{
   EDJE_STRUCT_APPEND(PARTS, fontses, FONTS, Edje_Fonts);
   FONTS = NULL;
}
parts_subblock ::= font.
{
   EDJE_STRUCT_APPEND(PARTS, fonts, FONT, Edje_Font);
   FONT = NULL;
}
parts_subblock ::= programs.
{
   EDJE_STRUCT_APPEND(PARTS, programses, PROGRAMS, Edje_Programs);
   PROGRAMS = NULL;
}
parts_subblock ::= program.
{
   EDJE_STRUCT_APPEND(PARTS, programs, PROGRAM, Edje_Program);
   PROGRAM = NULL;
}
parts_subblock ::= color_classes.
{
   EDJE_STRUCT_APPEND(PARTS, color_classes, COLOR_CLASS, Edje_Color_Class);
   COLOR_CLASS = NULL;
}
parts_subblock ::= images.
{
   EDJE_STRUCT_APPEND(PARTS, imageses, IMAGES, Edje_Images);
   IMAGES = NULL;
}
parts_subblock ::= set.
{
   EDJE_STRUCT_APPEND(PARTS, sets, SET, Edje_Set);
   SET = NULL;
}
parts_subblock ::= styles.
{
   EDJE_STRUCT_APPEND(PARTS, styles, STYLE, Edje_Style);
   STYLE = NULL;
}
parts_subblock ::= part.
{
   EDJE_STRUCT_APPEND(PARTS, parts, PART, Edje_Part);
   PART = NULL;
}
parts_subblock ::= script(S).
{
   PARTS->script = S;
}
parts_subblock ::= parts_property.
parts_property ::= PROPERTY(P) ID(I) ID(J) SEMICOLON.
{
   if (!edje_parser_property_check(P->text, "alias"))
     eina_hash_add(PARTS->aliases, STRDUPA_NOQUOTES(I->text), STRINGSHARE_ADD_NOQUOTES(J->text));
   else ERROR_SYNTAX(P);
   
   edje_parser_token_free(P);
   edje_parser_token_free(I);
   edje_parser_token_free(J);
}
/*************************** END PARTS SUB-BLOCKS *******************************/
/******************************* END PARTS CODE *********************************/

/******************************* START PART CODE ********************************/
part ::= part_start part_block.
part_start ::= doc_comment(C) PART.
{
   Edje_Part *p;

   EDJE_CREATE;
   p = edje_part_new();
   PARSER_APPEND(PART, p, Edje_Part);
   DBG("Part: %p", p);
   p->doc = C;
}
part_block ::= LB part_subblocks RB.
part_block ::= LB RB.
/******************************* PART SUB-BLOCKS ********************************/
part_subblocks ::= part_subblocks part_subblock.
part_subblocks ::= part_subblock.
/***************************************** DRAGABLE *************************************/
part_subblock ::= part_dragable.
part_dragable ::= part_dragable_start part_dragable_block.
part_dragable_start ::= DRAGABLE.
part_dragable_block ::= LB part_dragable_props RB.
part_dragable_block ::= LB RB.
part_dragable_block ::= DOT part_dragable_prop.
part_dragable_props ::= part_dragable_props part_dragable_prop.
part_dragable_props ::= part_dragable_prop.

part_dragable_prop ::= PROPERTY(P) ID(I) SEMICOLON.
{
   Edje_Part *p;

   p = PARSER_CURRENT(PART, Edje_Part);
   if (!edje_parser_property_check(P->text, "confine"))
     STRINGSHARE_REPLACE_NOQUOTES(p->dragable.confine, I->text);
   else if (!edje_parser_property_check(P->text, "events"))
     STRINGSHARE_REPLACE_NOQUOTES(p->dragable.events, I->text);
   else ERROR_SYNTAX(P);

   edje_parser_token_free(P);
   edje_parser_token_free(I);
}
part_dragable_prop ::= PROPERTY(P) ID(I) ID(J) ID(K) SEMICOLON.
{
   Edje_Part *p;
   Edje_Parser_Token *t[3];
   int i;

   t[0] = I;
   t[1] = J;
   t[2] = K;

   p = PARSER_CURRENT(PART, Edje_Part);
   if (!edje_parser_property_check(P->text, "x"))
     {
        for (i = 0; i < 3; i++)
          {
             if (!edje_parser_strtol(t[i]->text, &p->dragable.x[i]))
               ERROR_RANGE(t[i]);
          }
        if ((p->dragable.x[0] > 1) || (p->dragable.x[0] < -1)) /* first param is bool */
          ERROR_RANGE(I);
     }
   else if (!edje_parser_property_check(P->text, "y"))
     {
        for (i = 0; i < 3; i++)
          if (!edje_parser_strtol(t[i]->text, &p->dragable.y[i]))
            ERROR_RANGE(t[i]);
        if ((p->dragable.y[0] > 1) || (p->dragable.y[0] < -1))  /* first param is bool */
          ERROR_RANGE(I);
     }
   else ERROR_SYNTAX(P);
   
   edje_parser_token_free(P);
   edje_parser_token_free(I);
   edje_parser_token_free(J);
   edje_parser_token_free(K);
}
part_subblock ::= fonts.
{
   Edje_Part *p;

   p = PARSER_CURRENT(PART, Edje_Part);
   EDJE_STRUCT_APPEND(p, fontses, FONTS, Edje_Fonts);
   FONTS = NULL;
}
part_subblock ::= font.
{
   Edje_Part *p;

   p = PARSER_CURRENT(PART, Edje_Part);
   EDJE_STRUCT_APPEND(p, fonts, FONT, Edje_Font);
   FONT = NULL;
}
part_subblock ::= programs.
{
   Edje_Part *p;

   p = PARSER_CURRENT(PART, Edje_Part);
   EDJE_STRUCT_APPEND(p, programses, PROGRAMS, Edje_Programs);
   PROGRAMS = NULL;
}
part_subblock ::= program.
{
   Edje_Part *p;

   p = PARSER_CURRENT(PART, Edje_Part);
   EDJE_STRUCT_APPEND(p, programs, PROGRAM, Edje_Program);
   PROGRAM = NULL;
}
part_subblock ::= set.
{
   Edje_Part *p;

   p = PARSER_CURRENT(PART, Edje_Part);
   EDJE_STRUCT_APPEND(p, sets, SET, Edje_Set);
   SET = NULL;
}
part_subblock ::= styles.
{
   Edje_Part *p;

   p = PARSER_CURRENT(PART, Edje_Part);
   EDJE_STRUCT_APPEND(p, styles, STYLE, Edje_Style);
   STYLE = NULL;
}
part_subblock ::= color_classes.
{
   Edje_Part *p;

   p = PARSER_CURRENT(PART, Edje_Part);
   EDJE_STRUCT_APPEND(p, color_classes, COLOR_CLASS, Edje_Color_Class);
   COLOR_CLASS = NULL;
}
part_subblock ::= images.
{
   Edje_Part *p;

   p = PARSER_CURRENT(PART, Edje_Part);
   EDJE_STRUCT_APPEND(p, imageses, IMAGES, Edje_Images);
   IMAGES = NULL;
}
part_subblock ::= script(S).
{
   Edje_Part *p;

   p = PARSER_CURRENT(PART, Edje_Part);
   p->script = S;
}
part_subblock ::= part_description.
{
   Edje_Part *p;

   p = PARSER_CURRENT(PART, Edje_Part);
   EDJE_STRUCT_APPEND(p, descriptions, DESCRIPTION, Edje_Part_Description);
   DESCRIPTION = NULL;
}

/************************** START DESCRIPTION CODE ******************************/
part_description ::= part_description_start part_description_block.
part_description_start ::= doc_comment(C) DESCRIPTION.
{
   Edje_Part_Description *p;

   EDJE_CREATE;
   p = edje_part_description_new();
   PARSER_APPEND(DESCRIPTION, p, Edje_Part_Description);
   DBG("Part_Description: %p", p);
   p->doc = C;
}
part_description_block ::= LB part_description_subblocks RB.
part_description_block ::= LB RB.
part_description_block ::= DOT part_description_subblock.
/******************************* DESC SUB-BLOCKS ********************************/
part_description_subblocks ::= part_description_subblocks part_description_subblock.
part_description_subblocks ::= part_description_subblock.

part_description_subblock ::= color_classes.
{
   Edje_Part_Description *p;

   p = PARSER_CURRENT(DESCRIPTION, Edje_Part_Description);
   EDJE_STRUCT_APPEND(p, color_classes, COLOR_CLASS, Edje_Color_Class);
   COLOR_CLASS = NULL;
}
part_description_subblock ::= images.
{
   Edje_Part_Description *p;

   p = PARSER_CURRENT(DESCRIPTION, Edje_Part_Description);
   EDJE_STRUCT_APPEND(p, imageses, IMAGES, Edje_Images);
   IMAGES = NULL;
}
part_description_subblock ::= fonts.
{
   Edje_Part_Description *p;

   p = PARSER_CURRENT(DESCRIPTION, Edje_Part_Description);
   EDJE_STRUCT_APPEND(p, fontses, FONTS, Edje_Fonts);
   FONTS = NULL;
}
part_description_subblock ::= font.
{
   Edje_Part_Description *p;

   p = PARSER_CURRENT(DESCRIPTION, Edje_Part_Description);
   EDJE_STRUCT_APPEND(p, fonts, FONT, Edje_Font);
   FONT = NULL;
}
part_description_subblock ::= style.
{
   Edje_Part_Description *p;

   p = PARSER_CURRENT(DESCRIPTION, Edje_Part_Description);
   EDJE_STRUCT_APPEND(p, styles, STYLE, Edje_Style);
   STYLE = NULL;
}
part_description_subblock ::= programs.
{
   Edje_Part_Description *p;

   p = PARSER_CURRENT(DESCRIPTION, Edje_Part_Description);
   EDJE_STRUCT_APPEND(p, programses, PROGRAMS, Edje_Programs);
   PROGRAMS = NULL;
}
part_description_subblock ::= program.
{
   Edje_Part_Description *p;

   p = PARSER_CURRENT(DESCRIPTION, Edje_Part_Description);
   EDJE_STRUCT_APPEND(p, programs, PROGRAM, Edje_Program);
   PROGRAM = NULL;
}
part_description_subblock ::= script(S).
{
   Edje_Part_Description *p;

   p = PARSER_CURRENT(DESCRIPTION, Edje_Part_Description);
   p->script = S;
}
/*************************************** PROPERTY ************************************/
part_description_subblock ::= part_description_property.
part_description_property ::= PROPERTY(P) ID(I) SEMICOLON.
{
    Edje_Part_Description *p;

    p = PARSER_CURRENT(DESCRIPTION, Edje_Part_Description);

    if (!edje_parser_property_check(P->text, "color_class"))
      STRINGSHARE_REPLACE_NOQUOTES(p->color_class, I->text);
    else if (!edje_parser_property_check(P->text, "aspect_preference"))
      {
         if (!strcmp(I->text, "BOTH"))
           p->aspect_preference = EDJE_PART_DESCRIPTION_ASPECT_PREF_BOTH;
         else if (!strcmp(I->text, "VERTICAL"))
           p->aspect_preference = EDJE_PART_DESCRIPTION_ASPECT_PREF_VERTICAL;
         else if (!strcmp(I->text, "HORIZONTAL"))
           p->aspect_preference = EDJE_PART_DESCRIPTION_ASPECT_PREF_HORIZONTAL;
         else if (!strcmp(I->text, "NONE"))
           p->aspect_preference = EDJE_PART_DESCRIPTION_ASPECT_PREF_NONE;
         else ERROR_SYNTAX(I);
      }
   else if (!edje_parser_property_check(P->text, "visible"))
     {
        int i;
        if (!edje_parser_strtobool(I->text, &i))
          ERROR_RANGE(I);
        else
          p->visible = !!i;
     }
   else ERROR_SYNTAX(P);

   edje_parser_token_free(P);
   edje_parser_token_free(I);
}
part_description_property ::= PROPERTY(P) ID(I) ID(J) SEMICOLON.
{
    Edje_Part_Description *p;
    int i, j;

    p = PARSER_CURRENT(DESCRIPTION, Edje_Part_Description);

    if (!edje_parser_property_check(P->text, "inherit"))
      {
         STRINGSHARE_REPLACE_NOQUOTES(p->inherit.name, I->text);
         if (!edje_parser_strtod(J->text, &p->inherit.index))
           ERROR_RANGE(J);
      }
    else if (!edje_parser_property_check(P->text, "state"))
      {
         STRINGSHARE_REPLACE_NOQUOTES(p->state.name, I->text);
         if (!edje_parser_strtod(J->text, &p->state.index))
           ERROR_RANGE(J);
      }
   else if (!edje_parser_property_check(P->text, "fixed"))
     {
        if (!edje_parser_strtobool(I->text, &i))
          ERROR_RANGE(I);
        else if (!edje_parser_strtobool(J->text, &j))
          ERROR_RANGE(J);
        else
          {
             p->fixed[0] = !!i;
             p->fixed[1] = !!j;
          }
     }
   else if (!edje_parser_property_check(P->text, "align"))
     {
        if (!edje_parser_strtod(I->text, &p->align[0]))
          ERROR_RANGE(I);
        if (!edje_parser_strtod(J->text, &p->align[1]))
          ERROR_RANGE(J);
     }
   else if (!edje_parser_property_check(P->text, "aspect"))
     {
        if (!edje_parser_strtod(I->text, &p->aspect[0]))
          ERROR_RANGE(I);
        if (!edje_parser_strtod(J->text, &p->aspect[1]))
          ERROR_RANGE(J);
     }
   else if (!edje_parser_property_check(P->text, "min"))
     edje_parser_parse_min(ep, I, J, p->min, p->max);
   else if (!edje_parser_property_check(P->text, "max"))
     edje_parser_parse_max(ep, I, J, p->min, p->max);
   else if (!edje_parser_property_check(P->text, "step"))
     {
        if (strchr(I->text, '.') || (!edje_parser_strtol(I->text, &i) || (i < 0)))
          ERROR_RANGE(I);
        else if (strchr(J->text, '.') || !edje_parser_strtol(J->text, &j) || (j < 0))
          ERROR_RANGE(J);
        else
          {
             p->step[0] = i;
             p->step[1] = j;
          }
     }
    else ERROR_SYNTAX(P);

    edje_parser_token_free(P);
    edje_parser_token_free(I);
    edje_parser_token_free(J);
}
part_description_property ::= PROPERTY(P) ID(I) ID(J) ID(K) ID(L) SEMICOLON.
{
   Edje_Part_Description *p;
   int *colors[3];
   Edje_Parser_Token *tokens[4];

   p = PARSER_CURRENT(DESCRIPTION, Edje_Part_Description);
   tokens[0] = I;
   tokens[1] = J;
   tokens[2] = K;
   tokens[3] = L;
   colors[0] = p->color;
   colors[1] = p->color2;
   colors[2] = p->color3;
   if (!edje_parser_parse_color(ep, P, (Edje_Parser_Token**)tokens, (int**)colors) && (!ep->error))
     ERROR_SYNTAX(P);

   edje_parser_token_free(P);
   edje_parser_token_free(I);
   edje_parser_token_free(J);
   edje_parser_token_free(K);
   edje_parser_token_free(L);
}
/*************************************** PARAMS ******************************************/
part_description_subblock ::= part_description_params.
part_description_params ::= part_description_params_start part_description_params_block.
part_description_params_start ::= PARAMS.
part_description_params_block ::= LB part_description_params_subblocks RB.
part_description_params_block ::= LB RB.
part_description_params_block ::= DOT part_description_params_subblock.
part_description_params_subblocks ::= part_description_params_subblocks part_description_params_subblock.
part_description_params_subblocks ::= part_description_params_subblock.

part_description_params_subblock ::= part_description_param.
part_description_param ::= PROPERTY(P) ID(I) ID(J) SEMICOLON.
{
   Edje_Part_Description *p;
   Edje_Param *e;

   p = PARSER_CURRENT(DESCRIPTION, Edje_Part_Description);
   if (!edje_parser_property_check(P->text, "string"))
     {
        e = edje_param_new(EDJE_PARAM_TYPE_STRING);
        STRINGSHARE_REPLACE_NOQUOTES(e->data.s, J->text);
     }
   else if (!edje_parser_property_check(P->text, "choice"))
     {
        e = edje_param_new(EDJE_PARAM_TYPE_CHOICE);
        STRINGSHARE_REPLACE_NOQUOTES(e->data.s, J->text);
     }
   else if (!edje_parser_property_check(P->text, "int"))
     {
        e = edje_param_new(EDJE_PARAM_TYPE_INT);
        if (!edje_parser_strtol(J->text, &e->data.i))
          {
             free(e);
             ERROR_RANGE(J);
          }
     }
   else if (!edje_parser_property_check(P->text, "double"))
     {
        e = edje_param_new(EDJE_PARAM_TYPE_DOUBLE);
        if (!edje_parser_strtod(J->text, &e->data.d))
          {
             free(e);
             ERROR_RANGE(J);
          }
     }
   else if (!edje_parser_property_check(P->text, "bool"))
     {
        int i;
        e = edje_param_new(EDJE_PARAM_TYPE_BOOL);
        if (!edje_parser_strtobool(J->text, &i))
          {
             free(e);
             ERROR_RANGE(J);
          }
        else
          e->data.b = !!i;
     }
   else ERROR_SYNTAX(P);
   
   if (!ep->error) eina_hash_add(p->params, I->text, e);


   STRINGSHARE_REPLACE_NOQUOTES(e->data.s, J->text);
   eina_hash_add(p->params, I->text, e);

   edje_parser_token_free(P);
   edje_parser_token_free(I);
   edje_parser_token_free(J);
}
/************************************ PERSPECTIVE ****************************************/
part_description_subblock ::= part_description_perspective.
part_description_perspective ::= part_description_perspective_start part_description_perspective_block.
part_description_perspective_start ::= PERSPECTIVE.
part_description_perspective_block ::= LB part_description_perspective_subblocks RB.
part_description_perspective_block ::= LB RB.
part_description_perspective_block ::= DOT part_description_perspective_subblock.
part_description_perspective_subblocks ::= part_description_perspective_subblocks part_description_perspective_subblock.
part_description_perspective_subblocks ::= part_description_perspective_subblock.
part_description_perspective_subblock ::= PROPERTY(P) ID(I) SEMICOLON.
{
   Edje_Part_Description *p;

   p = PARSER_CURRENT(DESCRIPTION, Edje_Part_Description);
   if (!edje_parser_property_check(P->text, "zplane"))
     {
        if (strchr(I->text, '.') || (!edje_parser_strtol(I->text, &p->perspective.zplane)))
          ERROR_RANGE(I);
     }
   else if (!edje_parser_property_check(P->text, "focal"))
     {
        if (strchr(I->text, '.') || (!edje_parser_strtol(I->text, &p->perspective.focal)))
          ERROR_RANGE(I);
     }
   else ERROR_SYNTAX(P);

   edje_parser_token_free(P);
   edje_parser_token_free(I);
}
/***************************************** IMAGE *****************************************/
part_description_subblock ::= part_description_image.
part_description_image ::= part_description_image_start part_description_image_block.
part_description_image_start ::= doc_comment(C) IMAGE.
{
   Edje_Part_Description *p;
   Edje_Image *i;

   p = PARSER_CURRENT(DESCRIPTION, Edje_Part_Description);
   if (!p->image)
     p->image = edje_image_new();
   i = p->image;
   DBG("Image: %p", i);
   i->doc = C;
}
part_description_image_block ::= LB part_description_image_subblocks RB.
part_description_image_block ::= LB RB.
part_description_image_block ::= DOT part_description_image_subblock.
part_description_image_subblocks ::= part_description_image_subblocks part_description_image_subblock.
part_description_image_subblocks ::= part_description_image_subblock.
part_description_image_subblock ::= PROPERTY(P) ID(I) SEMICOLON.
{
   Edje_Part_Description *p;
   Edje_Image *i;

   p = PARSER_CURRENT(DESCRIPTION, Edje_Part_Description);
   i = p->image;
   if (!edje_parser_property_check(P->text, "normal"))
     STRINGSHARE_REPLACE_NOQUOTES(i->normal, I->text);
   else if (!edje_parser_property_check(P->text, "tween"))
     i->tween = eina_list_append(i->tween, STRINGSHARE_ADD_NOQUOTES(I->text));
   else if (!edje_parser_property_check(P->text, "image"))
     {
        if (strchr(I->text, ':')) // invalid filename characters
          ERROR_SYNTAX(I);
        else
          {
             Edje_Set_Image *s;

             s = PARSER_CURRENT(SET_IMAGE, Edje_Set_Image);
             if ((!s) || (s->filename))
               { /* play nice with Edje_Set objects */
                  s = edje_set_image_new();
                  PARSER_APPEND(SET_IMAGE, s, Edje_Set_Image);
                  DBG("Set image: %p", s);
               }
             STRINGSHARE_REPLACE_NOQUOTES(s->filename, I->text);
             s->comp = EDJE_COMPRESSION_TYPE_COMP;
             EDJE_STRUCT_APPEND(i, images, SET_IMAGE, Edje_Set_Image);
             SET_IMAGE = NULL;
          }
     }
   else if (!edje_parser_property_check(P->text, "middle"))
     {
        if ((!strcmp(I->text, "NONE")) || (!strcmp(I->text, "0")))
          i->middle = EDJE_IMAGE_MIDDLE_NONE;
        else if ((!strcmp(I->text, "DEFAULT")) || (!strcmp(I->text, "1")))
          i->middle = EDJE_IMAGE_MIDDLE_DEFAULT;
        else if (!strcmp(I->text, "SOLID"))
          i->middle = EDJE_IMAGE_MIDDLE_SOLID;
        else ERROR_SYNTAX(I);
     }
   else if (!edje_parser_property_check(P->text, "scale_hint"))
     {
        if ((!strcmp(I->text, "NONE")) || (!strcmp(I->text, "0")))
          i->middle = EDJE_IMAGE_SCALE_HINT_NONE;
        else if (!strcmp(I->text, "DYNAMIC"))
          i->middle = EDJE_IMAGE_SCALE_HINT_DYNAMIC;
        else if (!strcmp(I->text, "STATIC"))
          i->middle = EDJE_IMAGE_SCALE_HINT_STATIC;
     }
   else ERROR_SYNTAX(P);

   edje_parser_token_free(P);
   edje_parser_token_free(I);
}
part_description_image_subblock ::= PROPERTY(P) ID(I) ID(J) ID(K) ID(L) SEMICOLON.
{
   Edje_Part_Description *p;
   Edje_Image *i;
   Edje_Parser_Token *t[4];
   unsigned int x;

   t[0] = I;
   t[1] = J;
   t[2] = K;
   t[3] = L;

   p = PARSER_CURRENT(DESCRIPTION, Edje_Part_Description);
   i = p->image;
   if (!edje_parser_property_check(P->text, "border"))
     {
        for (x = 0; x < 4; x++)
          {
             if (!edje_parser_strtol(t[x]->text, &i->border[x]))
               ERROR_RANGE(t[x]);
          }
     }
   else ERROR_SYNTAX(P);

   edje_parser_token_free(P);
   edje_parser_token_free(I);
   edje_parser_token_free(J);
   edje_parser_token_free(K);
   edje_parser_token_free(L);
}
part_description_image_subblock ::= images_image.
{
   Edje_Part_Description *p;
   Edje_Image *i;

   p = PARSER_CURRENT(DESCRIPTION, Edje_Part_Description);
   i = p->image;
   EDJE_STRUCT_APPEND(i, images, SET_IMAGE, Edje_Set_Image);
   SET_IMAGE = NULL;
}
part_description_image_subblock ::= set.
{
   Edje_Part_Description *p;
   Edje_Image *i;

   p = PARSER_CURRENT(DESCRIPTION, Edje_Part_Description);
   i = p->image;
   EDJE_STRUCT_APPEND(i, sets, SET, Edje_Set);
   SET = NULL;
}
part_description_image_subblock ::= images.
{
   Edje_Part_Description *p;
   Edje_Image *i;

   p = PARSER_CURRENT(DESCRIPTION, Edje_Part_Description);
   i = p->image;
   EDJE_STRUCT_APPEND(i, imageses, IMAGES, Edje_Images);
   IMAGES = NULL;
}
/**************************************** FILL *******************************************/
part_description_subblock ::= part_description_fill.
part_description_fill ::= part_description_fill_start part_description_fill_block.
part_description_fill_start ::= FILL.
part_description_fill_block ::= LB part_description_fill_subblocks RB.
part_description_fill_block ::= LB RB.
part_description_fill_block ::= DOT part_description_fill_subblock.
part_description_fill_subblocks ::= part_description_fill_subblocks part_description_fill_subblock.
part_description_fill_subblocks ::= part_description_fill_subblock.

part_description_fill_subblock ::= PROPERTY(P) ID(I) SEMICOLON.
{
   Edje_Part_Description *p;

   p = PARSER_CURRENT(DESCRIPTION, Edje_Part_Description);
   if (!edje_parser_property_check(P->text, "smooth"))
     {
        int x;
        if (!edje_parser_strtobool(I->text, &x))
          ERROR_RANGE(I);
        p->fill.smooth = !!x;
     }
   else ERROR_SYNTAX(P);

   edje_parser_token_free(P);
   edje_parser_token_free(I);
}
part_description_fill_subblock ::= ORIGIN LB part_description_fill_subblock_origin_subblocks RB.
part_description_fill_subblock ::= ORIGIN LB RB.
part_description_fill_subblock ::= ORIGIN DOT part_description_fill_subblock_origin_subblock.
part_description_fill_subblock_origin_subblocks ::= part_description_fill_subblock_origin_subblocks part_description_fill_subblock_origin_subblock.
part_description_fill_subblock_origin_subblocks ::= part_description_fill_subblock_origin_subblock.
part_description_fill_subblock_origin_subblock ::= PROPERTY(P) ID(I) ID(J) SEMICOLON.
{
   Edje_Part_Description *p;

   p = PARSER_CURRENT(DESCRIPTION, Edje_Part_Description);

   if (!edje_parser_property_check(P->text, "relative"))
     {
        if (!edje_parser_strtod(I->text, &p->fill.origin.relative[0]))
          ERROR_RANGE(I);
        else if (!edje_parser_strtod(J->text, &p->fill.origin.relative[1]))
          ERROR_RANGE(J);
     }
   else if (!edje_parser_property_check(P->text, "offset"))
     {
        if (!edje_parser_strtol(I->text, &p->fill.origin.offset[0]))
          ERROR_RANGE(I);
        else if (!edje_parser_strtol(J->text, &p->fill.origin.offset[1]))
          ERROR_RANGE(J);
     }
   else ERROR_SYNTAX(P);

   edje_parser_token_free(P);
   edje_parser_token_free(I);
   edje_parser_token_free(J);
}
part_description_fill_subblock ::= SIZE LB part_description_fill_subblock_size_subblocks RB.
part_description_fill_subblock ::= SIZE LB RB.
part_description_fill_subblock ::= SIZE DOT part_description_fill_subblock_size_subblock.
part_description_fill_subblock_size_subblocks ::= part_description_fill_subblock_size_subblocks part_description_fill_subblock_size_subblock.
part_description_fill_subblock_size_subblocks ::= part_description_fill_subblock_size_subblock.
part_description_fill_subblock_size_subblock ::= PROPERTY(P) ID(I) ID(J) SEMICOLON.
{
   Edje_Part_Description *p;

   p = PARSER_CURRENT(DESCRIPTION, Edje_Part_Description);

   if (!edje_parser_property_check(P->text, "relative"))
     {
        if (!edje_parser_strtod(I->text, &p->fill.size.relative[0]))
          ERROR_RANGE(I);
        else if (!edje_parser_strtod(J->text, &p->fill.size.relative[1]))
          ERROR_RANGE(J);
     }
   else if (!edje_parser_property_check(P->text, "offset"))
     {
        if (!edje_parser_strtol(I->text, &p->fill.size.offset[0]))
          ERROR_RANGE(I);
        else if (!edje_parser_strtol(J->text, &p->fill.size.offset[1]))
          ERROR_RANGE(J);
     }
   else ERROR_SYNTAX(P);

   edje_parser_token_free(P);
   edje_parser_token_free(I);
   edje_parser_token_free(J);
}
/**************************************** TEXT *******************************************/
part_description_subblock ::= part_description_text.
part_description_text ::= part_description_text_start part_description_text_block.
part_description_text_start ::= TEXT(T).
{
   Edje_Part *p;

   p = PARSER_CURRENT(PART, Edje_Part);
   if ((p->type != EDJE_PART_TYPE_TEXT) && (p->type != EDJE_PART_TYPE_TEXTBLOCK))
     ERROR_TYPE(T);
   edje_parser_token_free(T);
}
part_description_text_block ::= LB part_description_text_props RB.
part_description_text_block ::= LB RB.
part_description_text_block ::= DOT part_description_text_prop.
part_description_text_props ::= part_description_text_props part_description_text_prop.
part_description_text_props ::= part_description_text_prop.
part_description_text_prop ::= PROPERTY(P) ID(I) ID(J) ID(K) SEMICOLON.
{
   Edje_Part_Description *p;

   p = PARSER_CURRENT(DESCRIPTION, Edje_Part_Description);
   if (!edje_parser_property_check(P->text, "text"))
     {
        eina_stringshare_del(p->type.text.text);
        p->type.text.text = eina_stringshare_printf("%s%s%s", STRDUPA_NOQUOTES(I->text), STRDUPA_NOQUOTES(J->text), STRDUPA_NOQUOTES(K->text));
     }
   else ERROR_SYNTAX(P);

   edje_parser_token_free(P);
   edje_parser_token_free(I);
   edje_parser_token_free(J);
   edje_parser_token_free(K);
}

part_description_text_prop ::= PROPERTY(P) ID(I) ID(J) SEMICOLON.
{
   Edje_Part_Description *p;
   int i, j;

   p = PARSER_CURRENT(DESCRIPTION, Edje_Part_Description);
#define EDJE_DESC_CHECK(NAME) \
   if (!edje_parser_property_check(P->text, #NAME)) \
     do { \
        if (!edje_parser_strtobool(I->text, &i)) \
          ERROR_RANGE(I); \
        if (!edje_parser_strtobool(J->text, &j)) \
          ERROR_RANGE(J); \
        p->type.text.NAME[0] = !!i; \
        p->type.text.NAME[1] = !!j; \
     } while (0)

   EDJE_DESC_CHECK(fit);
   else EDJE_DESC_CHECK(min);
   else EDJE_DESC_CHECK(max);
   else if (!edje_parser_property_check(P->text, "align"))
     {
        if (!edje_parser_strtod(I->text, &p->type.text.align[0]))
          ERROR_RANGE(I);
        if (!edje_parser_strtod(J->text, &p->type.text.align[1]))
          ERROR_RANGE(J);
     }
   else if (!edje_parser_property_check(P->text, "text"))
     {

        eina_stringshare_del(p->type.text.text);
        p->type.text.text = eina_stringshare_printf("%s%s", STRDUPA_NOQUOTES(I->text), STRDUPA_NOQUOTES(J->text));
     }
   else ERROR_SYNTAX(P);
#undef EDJE_DESC_CHECK
   edje_parser_token_free(P);
   edje_parser_token_free(I);
   edje_parser_token_free(J);
}
part_description_text_prop ::= PROPERTY(P) ID(I) SEMICOLON.
{
   Edje_Part_Description *p;

   p = PARSER_CURRENT(DESCRIPTION, Edje_Part_Description);
#define EDJE_DESC_CHECK(NAME) \
   if (!edje_parser_property_check(P->text, #NAME)) \
     STRINGSHARE_REPLACE_NOQUOTES(p->type.text.NAME, I->text)
     
   EDJE_DESC_CHECK(text_class);
   else EDJE_DESC_CHECK(text);
   else EDJE_DESC_CHECK(font);
   else EDJE_DESC_CHECK(source);
   else EDJE_DESC_CHECK(text_source);
   else EDJE_DESC_CHECK(style);
   else EDJE_DESC_CHECK(repch);
   else if (!edje_parser_property_check(P->text, "size"))
     {
        if (strchr(I->text, '.') || (!edje_parser_strtol(I->text, &p->type.text.size) || (p->type.text.size < 1)))
          ERROR_RANGE(I);
     }
   else if (!edje_parser_property_check(P->text, "elipsis"))
     {
        if (!edje_parser_strtod(I->text, &p->type.text.elipsis))
          ERROR_RANGE(I);
     }
   else ERROR_SYNTAX(P);
   
#undef EDJE_DESC_CHECK
   edje_parser_token_free(P);
   edje_parser_token_free(I);
}
/**************************************** BOX *******************************************/
part_description_subblock ::= part_description_box.
part_description_box ::= part_description_box_start part_description_box_block.
part_description_box_start ::= BOX(T).
{
   Edje_Part *p;

   p = PARSER_CURRENT(PART, Edje_Part);
   if (p->type != EDJE_PART_TYPE_BOX)
     ERROR_TYPE(T);
   edje_parser_token_free(T);
}
part_description_box_block ::= LB part_description_box_props RB.
part_description_box_block ::= LB RB.
part_description_box_block ::= DOT part_description_box_prop.
part_description_box_props ::= part_description_box_props part_description_box_prop.
part_description_box_props ::= part_description_box_prop.
part_description_box_prop ::= PROPERTY(P) ID(I) ID(J) SEMICOLON.
{
   Edje_Part_Description *p;
   int i, j;

   p = PARSER_CURRENT(DESCRIPTION, Edje_Part_Description);

   if (!edje_parser_property_check(P->text, "min"))
     {
        if (!edje_parser_strtobool(I->text, &i))
          ERROR_RANGE(I);
        else if (!edje_parser_strtobool(J->text, &j))
          ERROR_RANGE(J);
        p->type.box.min[0] = !!i;
        p->type.box.min[1] = !!j;
     }
   else if (!edje_parser_property_check(P->text, "padding"))
     {
        if (!edje_parser_strtol(I->text, &p->type.box.padding[0]))
          ERROR_RANGE(I);
        else if (!edje_parser_strtol(J->text, &p->type.box.padding[1]))
          ERROR_RANGE(J);
     }
   else if (!edje_parser_property_check(P->text, "align"))
     {
        if (!edje_parser_strtod(I->text, &p->type.box.align[0]))
          ERROR_RANGE(I);
        if (!edje_parser_strtod(J->text, &p->type.box.align[1]))
          ERROR_RANGE(J);
     }
   else if (!edje_parser_property_check(P->text, "layout"))
     {
#define EDJE_DESC_CHECK(TEXT, VALUE) \
  if (!strcmp(I->text, #TEXT)) \
    p->type.box.primary = EDJE_BOX_LAYOUT_##VALUE

        EDJE_DESC_CHECK(horizontal, HORIZONTAL);
        else EDJE_DESC_CHECK(vertical, VERTICAL);
        else EDJE_DESC_CHECK(horizontal_homogeneous, HORIZONTAL_HOMOGENEOUS);
        else EDJE_DESC_CHECK(vertical_homogeneous, VERTICAL_HOMOGENEOUS);
        else EDJE_DESC_CHECK(horizontal_max, HORIZONTAL_MAX);
        else EDJE_DESC_CHECK(vertical_max, VERTICAL_MAX);
        else EDJE_DESC_CHECK(horizontal_flow, HORIZONTAL_FLOW);
        else EDJE_DESC_CHECK(stack, STACK);
        else p->type.box.primary = EDJE_BOX_LAYOUT_CUSTOM;
#undef EDJE_DESC_CHECK
#define EDJE_DESC_CHECK(TEXT, VALUE) \
  if (!strcmp(J->text, #TEXT)) \
    p->type.box.fallback = EDJE_BOX_LAYOUT_##VALUE
    
        EDJE_DESC_CHECK(horizontal, HORIZONTAL);
        else EDJE_DESC_CHECK(vertical, VERTICAL);
        else EDJE_DESC_CHECK(horizontal_homogeneous, HORIZONTAL_HOMOGENEOUS);
        else EDJE_DESC_CHECK(vertical_homogeneous, VERTICAL_HOMOGENEOUS);
        else EDJE_DESC_CHECK(horizontal_max, HORIZONTAL_MAX);
        else EDJE_DESC_CHECK(vertical_max, VERTICAL_MAX);
        else EDJE_DESC_CHECK(horizontal_flow, HORIZONTAL_FLOW);
        else EDJE_DESC_CHECK(stack, STACK);
        else p->type.box.fallback = EDJE_BOX_LAYOUT_CUSTOM;
     }
   else ERROR_SYNTAX(P);
#undef EDJE_DESC_CHECK
   edje_parser_token_free(P);
   edje_parser_token_free(I);
   edje_parser_token_free(J);
}
part_description_box_prop ::= PROPERTY(P) ID(I) SEMICOLON.
{
   Edje_Part_Description *p;

   p = PARSER_CURRENT(DESCRIPTION, Edje_Part_Description);
   if (!edje_parser_property_check(P->text, "layout"))
     {
#define EDJE_DESC_CHECK(TEXT, VALUE) \
  if (!strcmp(I->text, #TEXT)) \
    p->type.box.primary = EDJE_BOX_LAYOUT_##VALUE

        EDJE_DESC_CHECK(horizontal, HORIZONTAL);
        else EDJE_DESC_CHECK(vertical, VERTICAL);
        else EDJE_DESC_CHECK(horizontal_homogeneous, HORIZONTAL_HOMOGENEOUS);
        else EDJE_DESC_CHECK(vertical_homogeneous, VERTICAL_HOMOGENEOUS);
        else EDJE_DESC_CHECK(horizontal_max, HORIZONTAL_MAX);
        else EDJE_DESC_CHECK(vertical_max, VERTICAL_MAX);
        else EDJE_DESC_CHECK(horizontal_flow, HORIZONTAL_FLOW);
        else EDJE_DESC_CHECK(stack, STACK);
        else p->type.box.primary = EDJE_BOX_LAYOUT_CUSTOM;
     }
   else ERROR_SYNTAX(P);
#undef EDJE_DESC_CHECK
   edje_parser_token_free(P);
   edje_parser_token_free(I);
}
/******************************************** MAP ***************************************/
part_description_subblock ::= part_description_map.
part_description_map ::= part_description_map_start part_description_map_block.
part_description_map_start ::= MAP.
part_description_map_block ::= LB part_description_map_props RB.
part_description_map_block ::= LB RB.
part_description_map_block ::= DOT part_description_map_prop.
part_description_map_props ::= part_description_map_props part_description_map_prop.
part_description_map_props ::= part_description_map_prop.

part_description_map_prop ::= PROPERTY(P) ID(I) SEMICOLON.
{
   Edje_Part_Description *p;
   int i;

   p = PARSER_CURRENT(DESCRIPTION, Edje_Part_Description);
#define EDJE_MAP_CHECK(NAME) \
   if (!edje_parser_property_check(P->text, #NAME)) \
     do { \
        if (!edje_parser_strtobool(I->text, &i)) \
          ERROR_RANGE(I); \
        else \
          p->type.map.NAME = !!i; \
     } while (0)

   EDJE_MAP_CHECK(on);
   else EDJE_MAP_CHECK(smooth);
   else EDJE_MAP_CHECK(alpha);
   else EDJE_MAP_CHECK(backface_cull);
   else EDJE_MAP_CHECK(perspective_on);
   else if (!edje_parser_property_check(P->text, "perspective"))
     STRINGSHARE_REPLACE_NOQUOTES(p->type.map.perspective, I->text);
   else if (!edje_parser_property_check(P->text, "light"))
     STRINGSHARE_REPLACE_NOQUOTES(p->type.map.light, I->text);
   else ERROR_SYNTAX(P);
#undef EDJE_MAP_CHECK
   edje_parser_token_free(P);
   edje_parser_token_free(I);
}
part_description_map_prop ::= part_description_map_rotation.
part_description_map_rotation ::= part_description_map_rotation_start part_description_map_rotation_block.
part_description_map_rotation_start ::= ROTATION.
part_description_map_rotation_block ::= LB part_description_map_rotation_subblocks RB.
part_description_map_rotation_block ::= LB RB.
part_description_map_rotation_block ::= DOT part_description_map_rotation_subblock.
part_description_map_rotation_subblocks ::= part_description_map_rotation_subblocks part_description_map_rotation_subblock.
part_description_map_rotation_subblocks ::= part_description_map_rotation_subblock.
part_description_map_rotation_subblock ::= PROPERTY(P) ID(I) SEMICOLON.
{
   Edje_Part_Description *p;

   p = PARSER_CURRENT(DESCRIPTION, Edje_Part_Description);
#define EDJE_MAP_CHECK(NAME) \
   if (!edje_parser_property_check(P->text, #NAME)) \
     do { \
        if (!edje_parser_strtod(I->text, &p->type.map.rotation.NAME)) \
          ERROR_RANGE(I); \
     } while (0)

   EDJE_MAP_CHECK(x);
   else EDJE_MAP_CHECK(y);
   else EDJE_MAP_CHECK(z);
   else if (!edje_parser_property_check(P->text, "center"))
     STRINGSHARE_REPLACE_NOQUOTES(p->type.map.rotation.center, I->text);
   else ERROR_SYNTAX(P);
#undef EDJE_MAP_CHECK
   edje_parser_token_free(P);
   edje_parser_token_free(I);
}
/***************************************** REL1/REL2 ************************************/
part_description_subblock ::= part_description_relone. { REL = NULL; }
part_description_subblock ::= part_description_reltwo. { REL = NULL; }
part_description_relone ::= part_description_relone_start part_description_rel_props.
part_description_reltwo ::= part_description_reltwo_start part_description_rel_props.
part_description_relone_start ::= REL1.
{
   Edje_Part_Description *p;

   p = PARSER_CURRENT(DESCRIPTION, Edje_Part_Description);
   DBG("Rel1");
   REL = &p->rel[0];
}
part_description_reltwo_start ::= REL2.
{
   Edje_Part_Description *p;

   p = PARSER_CURRENT(DESCRIPTION, Edje_Part_Description);
   DBG("Rel2");
   REL = &p->rel[1];
}
part_description_rel_props ::= LB relative_properties RB.
part_description_rel_props ::= LB RB.
part_description_rel_props ::= DOT relative_property.
relative_properties ::= relative_properties relative_property.
relative_properties ::= relative_property.
relative_property ::= PROPERTY(P) ID(I) ID(J) SEMICOLON.
{

   if (!edje_parser_property_check(P->text, "offset"))
     {
        if (!edje_parser_strtol(I->text, &REL->offset[0]))
          ERROR_RANGE(I);
        else if (!edje_parser_strtol(J->text, &REL->offset[1]))
          ERROR_RANGE(J);
     }
   else if (!edje_parser_property_check(P->text, "relative"))
     {
        if (!edje_parser_strtod(I->text, &REL->relative[0]))
          ERROR_RANGE(I);
        else if (!edje_parser_strtod(J->text, &REL->relative[1]))
          ERROR_RANGE(J);
     }
   else ERROR_SYNTAX(P);
   
   edje_parser_token_free(P);
   edje_parser_token_free(I);
   edje_parser_token_free(J);
}
relative_property ::= PROPERTY(P) ID(I) SEMICOLON.
{
   if (!edje_parser_property_check(P->text, "to"))
     STRINGSHARE_REPLACE_NOQUOTES(REL->to, I->text);
   else if (!edje_parser_property_check(P->text, "to_x"))
     STRINGSHARE_REPLACE_NOQUOTES(REL->to_x, I->text);
   else if (!edje_parser_property_check(P->text, "to_y"))
     STRINGSHARE_REPLACE_NOQUOTES(REL->to_y, I->text);
   else ERROR_SYNTAX(P);
   edje_parser_token_free(P);
   edje_parser_token_free(I);
}
/******************************* END DESC SUB-BLOCKS ****************************/
/************************** END DESCRIPTION CODE ********************************/
/************************** START PART PROPERTY CODE ****************************/
part_subblock ::= part_property.

part_property ::= PROPERTY(P) ID(I) SEMICOLON.
{
   Edje_Part *p;
   int i;

   p = PARSER_CURRENT(PART, Edje_Part);
#define EDJE_PART_CHECK(TYPE) \
if (!edje_parser_property_check(P->text, #TYPE)) \
  STRINGSHARE_REPLACE_NOQUOTES(p->TYPE, I->text)
  
   EDJE_PART_CHECK(clip_to);
   else EDJE_PART_CHECK(name);
   else EDJE_PART_CHECK(source);
   else EDJE_PART_CHECK(source2);
   else EDJE_PART_CHECK(source3);
   else EDJE_PART_CHECK(source4);
   else EDJE_PART_CHECK(source5);
   else EDJE_PART_CHECK(source6);
#undef EDJE_PART_CHECK
   else if (!edje_parser_property_check(P->text, "type"))
     {
#define EDJE_PART_CHECK(TYPE) \
if (!strcmp(I->text, #TYPE)) \
  p->type = EDJE_PART_TYPE_##TYPE

        EDJE_PART_CHECK(RECT);
        else EDJE_PART_CHECK(TEXT);
        else EDJE_PART_CHECK(IMAGE);
        else EDJE_PART_CHECK(SWALLOW);
        else EDJE_PART_CHECK(TEXTBLOCK);
        else EDJE_PART_CHECK(GROUP);
        else EDJE_PART_CHECK(BOX);
        else EDJE_PART_CHECK(TABLE);
        else EDJE_PART_CHECK(EXTERNAL);
        else ERROR_SYNTAX(I);
#undef EDJE_PART_CHECK
     }
   else if (!edje_parser_property_check(P->text, "ignore_flags"))
     {
        if (!strcmp(I->text, "NONE"))
          p->ignore_flags = EDJE_IGNORE_FLAG_NONE;
        else if (!strcmp(I->text, "ON_HOLD"))
          p->ignore_flags = EDJE_IGNORE_FLAG_ON_HOLD;
        else
          ERROR_SYNTAX(I);
     }
   else if (!edje_parser_property_check(P->text, "pointer_mode"))
     {
        if (!strcmp(I->text, "AUTOGRAB"))
          p->pointer_mode = EDJE_POINTER_MODE_AUTOGRAB;
        else if (!strcmp(I->text, "NOGRAB"))
          p->pointer_mode = EDJE_POINTER_MODE_NOGRAB;
        else
          ERROR_SYNTAX(I);
     }
   else if (!edje_parser_property_check(P->text, "effect"))
     {
#define EDJE_PART_CHECK(TYPE) \
if (!strcmp(I->text, #TYPE)) \
  p->effect = EDJE_PART_EFFECT_##TYPE

        EDJE_PART_CHECK(NONE);
        else EDJE_PART_CHECK(PLAIN);
        else EDJE_PART_CHECK(OUTLINE);
        else EDJE_PART_CHECK(SOFT_OUTLINE);
        else EDJE_PART_CHECK(SHADOW);
        else EDJE_PART_CHECK(SOFT_SHADOW);
        else EDJE_PART_CHECK(OUTLINE_SHADOW);
        else EDJE_PART_CHECK(OUTLINE_SOFT_SHADOW);
        else EDJE_PART_CHECK(FAR_SHADOW);
        else EDJE_PART_CHECK(FAR_SOFT_SHADOW);
        else EDJE_PART_CHECK(GLOW);
        else ERROR_SYNTAX(I);
#undef EDJE_PART_CHECK
     }
   else if (!edje_parser_property_check(P->text, "entry_mode"))
     {
#define EDJE_PART_CHECK(TYPE) \
if (!strcmp(I->text, #TYPE)) \
  p->entry_mode = EDJE_PART_ENTRY_MODE_##TYPE

        EDJE_PART_CHECK(NONE);
        else EDJE_PART_CHECK(PLAIN);
        else EDJE_PART_CHECK(EDITABLE);
        else EDJE_PART_CHECK(PASSWORD);
        else ERROR_SYNTAX(I);
#undef EDJE_PART_CHECK
     }
   else if (!edje_parser_property_check(P->text, "select_mode"))
     {
        if (!strcmp(I->text, "DEFAULT"))
          p->select_mode = EDJE_PART_SELECT_MODE_DEFAULT;
        else if (!strcmp(I->text, "EXPLICIT_DEFAULT"))
          p->select_mode = EDJE_PART_SELECT_MODE_EXPLICIT_DEFAULT;
        else
          ERROR_SYNTAX(I);
     }
#define EDJE_PART_CHECK(TYPE) \
if (!edje_parser_property_check(P->text, #TYPE)) \
  if (!edje_parser_strtobool(I->text, &i)) \
    ERROR_RANGE(I); \
  else \
  p->TYPE = !!i

   else EDJE_PART_CHECK(mouse_events);
   else EDJE_PART_CHECK(repeat_events);
   else EDJE_PART_CHECK(scale);
   else EDJE_PART_CHECK(precise_is_inside);
   else EDJE_PART_CHECK(use_alternate_font_metrics);
   else EDJE_PART_CHECK(multiline);
#undef EDJE_PART_CHECK

   else
     ERROR_SYNTAX(P);
   edje_parser_token_free(P);
   edje_parser_token_free(I);
}
/*************************** END PART PROPERTY CODE ****************************/
/*************************** END PART SUB-BLOCKS *******************************/
/******************************* END PART CODE *********************************/
