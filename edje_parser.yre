/*
 * Copyright 2011 Mike Blumenkrantz <mike@zentific.com>
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published
 * by the Free Software Foundation, either version 2.1 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the 
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */

%name edje_parser_
%token_prefix EDJE_
%token_type {Edje_Token *}
%token_destructor {edje_parser_token_free($$);}
%extra_argument {Edje_Parser *ep}
%syntax_error {ERROR_SYNTAX(TOKEN);}
%stack_size 2000
%stack_overflow {eina_stringshare_replace(&ep->error, "Parser stack overflow!\n");}
%include {
#include "edje_parser_lib.h"
#include "edje.h"
#include "edje_parser.h"
#include "edje_parser_macros.h"
#include <ctype.h>
#include <errno.h>

#define YYCTYPE  char
#define YYCURSOR c
#define YYMARKER q
#define YYCTXMARKER t

#define EDJE_EOF     0
#define EDJE_UNKNOWN (-1)

#define RET(tok) return edje_parser_token_new(s, tok, c - b)

#define NEXT \
       edje_parser_stream_next(s, c - b); \
       b = c

extern void *edje_parser_Alloc(void *(*)(size_t));
extern void  edje_parser_Free(void *, void (*)(void *));
extern void  edje_parser_(void *,
                         int,
                         Edje_Token *,
                         Edje_Parser *);
/* for reference
extern void        edje_parser_Trace(FILE *,
                                    char *);
*/
   static Edje_Token *
   edje_parser_stream_to_token(Edje_Stream *s)
   {
      const char *c, *b, *q;
      int brace_open = 0;

      if (s->length == s->index)
        return edje_parser_token_new(s, EDJE_EOF, 0);

      c = b = s->buffer + s->index;

main:
/*!re2c

   re2c:indent:top       = 2;
   re2c:indent:string    = " ";
   re2c:yyfill:enable    = 0;

   NONPRINT   = [^];
   ENDINPUT   = "\000";
   D     = [-]?[0-9]+;
   N     = [a-z0-9_];

   SL_COMMENT = "//" (.\ENDINPUT)* ("\n"|ENDINPUT);

   SL_COMMENT         { NEXT; goto main; }
   "/*"               { goto commentblock; }
   [ \t\n\r]+         { NEXT; goto main; }

   "collections"      { RET(EDJE_COLLECTIONS); }
   "externals"        { RET(EDJE_EXTERNALS); }
   "color_classes"    { RET(EDJE_COLOR_CLASSES); }
   "color_class"      { RET(EDJE_COLOR_CLASS); }
   "description"      { RET(EDJE_DESCRIPTION); }
   "fonts"            { RET(EDJE_FONTS); }
   "text"             { RET(EDJE_TEXT); }
   "map"              { RET(EDJE_MAP); }
   "rotation"         { RET(EDJE_ROTATION); }
   "perspective"      { RET(EDJE_PERSPECTIVE); }
   "programs"         { RET(EDJE_PROGRAMS); }
   "program"          { RET(EDJE_PROGRAM); }
   "script"
{
   while (c++ && (*c != '}'))
     if (*c == '{') brace_open++;
   goto scriptblock;
}
   "font"             { RET(EDJE_FONT); }
   "rel1"             { RET(EDJE_REL1); }
   "rel2"             { RET(EDJE_REL2); }
   "parts"            { RET(EDJE_PARTS); }
   "params"           { RET(EDJE_PARAMS); }
   "part"             { RET(EDJE_PART); }
   "group"            { RET(EDJE_GROUP); }
   "RAW"              { RET(EDJE_RAW); }
   "COMP"             { RET(EDJE_COMP); }
   "LOSSY"            { RET(EDJE_LOSSY); }
   "USER"             { RET(EDJE_USER); }
   "\""[\043-\176 !]+"\"" { RET(EDJE_ID); }
   ([a-z]N+)":"       { RET(EDJE_PROPERTY); }

   [A-Z_]+             { RET(EDJE_CAPS); }
   "{"                { RET(EDJE_LB); }
   "}"                { RET(EDJE_RB); }

   D("."[0-9]+)?      { RET(EDJE_NUMBER); }

   ";"                { RET(EDJE_SEMICOLON); }
   ":"                { RET(EDJE_COLON); }
   "."                { RET(EDJE_DOT); }
   ENDINPUT           { RET(EDJE_EOF); }
   NONPRINT           { RET(EDJE_UNKNOWN); }

 */

scriptblock:
/*!re2c
  "{"         { brace_open++; c++; goto scriptblock; }
  "}"         { if (--brace_open < 1) RET(EDJE_EMBRYO); c++; goto scriptblock; }
  [^{}]       { c++; goto scriptblock; }
  ENDINPUT             { RET(EDJE_UNKNOWN); }
*/

commentblock:
/*!re2c
   "*/"                { NEXT; goto main; }
  [\040-\176\t\n\r]   { NEXT; goto commentblock; }
  ENDINPUT             { RET(EDJE_UNKNOWN); }
  NONPRINT             { goto commentblock; }
*/

     return NULL;
   }

   Edje *edje_parse_string(const char *str, Eina_Bool *err)
   {
      return edje_parser_string_parse(str, err, edje_parser_, edje_parser_Alloc, edje_parser_Free, edje_parser_stream_to_token);
   }
   Edje *edje_parse_file(const char *path, Eina_Bool *err)
   {
      return edje_parser_file_parse(path, err, edje_parser_, edje_parser_Alloc, edje_parser_Free, edje_parser_stream_to_token);
   }
}

edje ::= toplevel_blocks.

toplevel_blocks ::= toplevel_block.
toplevel_blocks ::= toplevel_blocks toplevel_block.
toplevel_block ::= collection.
{
   EDJE_CREATE;
   EDJE_APPEND(collections, COLLECTION, Edje_Collection);
   COLLECTION = NULL;
}
toplevel_block ::= images.
{
   EDJE_CREATE;
   EDJE_APPEND(imageses, IMAGES, Edje_Images);
   IMAGES = NULL;
}
toplevel_block ::= fonts.
{
   EDJE_CREATE;
   EDJE_APPEND(fontses, FONTS, Edje_Fonts);
   FONTS = NULL;
}
toplevel_block ::= externals.
{
   EDJE_CREATE;
   EDJE_APPEND(externals, EXTERNAL, Edje_External);
   EXTERNAL = NULL;
}
/*
toplevel_block ::= sets_block(B).
{
   EDJE_CREATE;
   EDJE_APPEND(sets);
}

toplevel_block ::= data_block(B).
{
   EDJE_CREATE;
   EDJE_APPEND(data);
}
toplevel_block ::= styles_block(B).
{
   EDJE_CREATE;
   EDJE_APPEND(styles);
}
*/
toplevel_block ::= color_classes.
{
   EDJE_CREATE;
   EDJE_APPEND(color_classes, COLOR_CLASS, Edje_Color_Class);
   COLOR_CLASS = NULL;
}

%type doc_comment {const char *}
doc_comment(Y) ::= . {Y = NULL;}
doc_comment(Y) ::= DOC(X).
{
   DBG("Comment: %s", X->text);
   Y = X->text;
   X->text = NULL;
   edje_parser_token_free(X);
}

%type script {const char *}
script(S) ::= EMBRYO(E).
{
   const char *p, *q;

   p = E->text + 7;
   while (p && (isspace(*p) || (*p == '{')))
     p++;
   q = E->text + eina_stringshare_strlen(E->text) - 1;
   while (q && (isspace(*q) || (*q == '}')))
     q--;

   S = eina_stringshare_add_length(p, q - p + 1);
   DBG("Script: '%s'", S);
   edje_parser_token_free(E);
}
/******************************* START COLLECTIONS CODE *********************************/
collection ::= collection_start collection_block.
collection_start ::= doc_comment(C) COLLECTIONS.
{
   Edje_Collection *c;
   
   EDJE_CREATE;
   c = edje_collection_new();
   PARSER_APPEND(COLLECTION, c, Edje_Collection);
   DBG("Collection: %p", c);
   c->doc = C;
}
collection_block ::= LB collections_subblocks RB.
collections_subblocks ::= collections_subblocks collections_subblock.
collections_subblocks ::= collections_subblock.

collections_subblock ::= group.
{
   Edje_Collection *c;
   c = PARSER_CURRENT(COLLECTION, Edje_Collection);
   EDJE_STRUCT_APPEND(c, groups, GROUP, Edje_Group);
   GROUP = NULL;
}
collections_subblock ::= color_classes.
{
   Edje_Collection *c;
   c = PARSER_CURRENT(COLLECTION, Edje_Collection);
   EDJE_STRUCT_APPEND(c, color_classes, COLOR_CLASS, Edje_Color_Class);
   COLOR_CLASS = NULL;
}
collections_subblock ::= images.
{
   Edje_Collection *c;
   c = PARSER_CURRENT(COLLECTION, Edje_Collection);
   EDJE_STRUCT_APPEND(c, imageses, IMAGES, Edje_Images);
   IMAGES = NULL;
}
collections_subblock ::= externals.
{
   Edje_Collection *c;
   c = PARSER_CURRENT(COLLECTION, Edje_Collection);
   EDJE_STRUCT_APPEND(c, externals, EXTERNAL, Edje_External);
   EXTERNAL = NULL;
}
collections_subblock ::= fonts.
{
   Edje_Collection *c;
   c = PARSER_CURRENT(COLLECTION, Edje_Collection);
   EDJE_STRUCT_APPEND(c, fontses, FONTS, Edje_Fonts);
   FONTS = NULL;
}
/******************************* END COLLECTIONS CODE ***********************************/
/******************************* START EXTERNALS CODE ***************************************/
externals ::= externals_start externals_block.
externals_start ::= doc_comment EXTERNALS.
externals_block ::= LB externals_subblocks RB.
externals_block ::= DOT externals_subblock.
externals_subblocks ::= externals_subblocks externals_subblock.
externals_subblocks ::= externals_subblock.

externals_subblock ::= PROPERTY(P) ID(I) SEMICOLON.
{
   Edje_External *e;

   if (!strcmp(P->text, "external:"))
     {
        e = edje_external_new();
        STRINGSHARE_REPLACE_NOQUOTES(e->external, I->text);
        PARSER_APPEND(EXTERNAL, e, Edje_External);
     }
   else ERROR_SYNTAX(P);

   edje_parser_token_free(P);
   edje_parser_token_free(I);
}
/******************************* END EXTERNALS CODE *****************************************/
/******************************* START FONTS CODE ***************************************/
fonts ::= fonts_start fonts_block.
fonts_start ::= doc_comment(C) FONTS.
{
   Edje_Fonts *f;

   EDJE_CREATE;
   f = edje_fonts_new();
   PARSER_APPEND(FONTS, f, Edje_Fonts);
   DBG("Fonts: %p", f);
   f->doc = C;
}
fonts_block ::= LB fonts_subblocks RB.
fonts_block ::= DOT fonts_subblock.
fonts_subblocks ::= fonts_subblocks fonts_subblock.
fonts_subblocks ::= fonts_subblock.

fonts_subblock ::= font.
{
   Edje_Fonts *f;

   f = PARSER_CURRENT(FONTS, Edje_Fonts);
   EDJE_STRUCT_APPEND(f, fonts, FONT, Edje_Font);
   FONT = NULL;
}
/******************************* END FONTS CODE *****************************************/
/******************************* START FONT CODE ****************************************/
font ::= doc_comment(C) FONT COLON ID(I) ID(J) SEMICOLON.
{
   Edje_Font *f;

   f = edje_font_new();
   PARSER_APPEND(FONT, f, Edje_Font);
   DBG("Font: %p", f);
   f->doc = C;

   STRINGSHARE_REPLACE_NOQUOTES(f->name, I->text);
   STRINGSHARE_REPLACE_NOQUOTES(f->alias, J->text);

   edje_parser_token_free(I);
   edje_parser_token_free(J);
}
/******************************* END FONT CODE ******************************************/
/******************************* START COLOR_CLASS CODE *********************************/
color_classes ::= color_classes_start color_classes_block.
color_classes_start ::= doc_comment COLOR_CLASSES.
color_classes_block ::= LB color_class RB.

color_class ::= color_class color_class_start color_class_block.
color_class ::= color_class_start color_class_block.
color_class_start ::= doc_comment(C) COLOR_CLASS.
{
   Edje_Color_Class *c;

   c = edje_color_class_new();
   PARSER_APPEND(COLOR_CLASS, c, Edje_Color_Class);
   c->doc = C;
}
color_class_block ::= LB color_class_properties RB.
color_class_properties ::= color_class_properties color_class_property.
color_class_properties ::= color_class_property.
color_class_property ::= PROPERTY ID(I) SEMICOLON.
{
   Edje_Color_Class *c;

   c = PARSER_CURRENT(COLOR_CLASS, Edje_Color_Class);
   DBG("Color class name: %s", I->text);
   c->name = eina_stringshare_add(I->text);
   edje_parser_token_free(I);
}
color_class_property ::= PROPERTY(P) NUMBER(I) NUMBER(J) NUMBER(K) NUMBER(L) SEMICOLON.
{

   Edje_Color_Class *c;
   int *colors[3];
   Edje_Token *tokens[4];

   c = PARSER_CURRENT(COLOR_CLASS, Edje_Color_Class);

   DBG("Color class property: %s:%s %s %s %s", P->text, I->text, J->text, K->text, L->text);
   tokens[0] = I;
   tokens[1] = J;
   tokens[2] = K;
   tokens[3] = L;
   colors[0] = c->color;
   colors[1] = c->color2;
   colors[2] = c->color3;
   if (!edje_parser_parse_color(ep, P, (Edje_Token**)tokens, (int**)colors) && (!ep->error))
     ERROR_SYNTAX(P);

   edje_parser_token_free(P);
   edje_parser_token_free(I);
   edje_parser_token_free(J);
   edje_parser_token_free(K);
   edje_parser_token_free(L);
}
/******************************* END COLOR_CLASS CODE *********************************/
/******************************* START PROGRAMS CODE **********************************/
programs ::= programs_start programs_blocks.
programs_start ::= doc_comment(C) PROGRAMS.
{
   Edje_Programs *p;

   EDJE_CREATE;   
   p = edje_programs_new();
   PARSER_APPEND(PROGRAMS, p, Edje_Programs);
   DBG("Programs: %p", p);
   p->doc = C;
}
programs_blocks ::= LB programs_subblocks RB.
programs_blocks ::= DOT programs_subblock.
programs_subblocks ::= programs_subblocks programs_subblock.
programs_subblocks ::= programs_subblock.

programs_subblock ::= program.
{
   Edje_Programs *p;

   p = PARSER_CURRENT(PROGRAMS, Edje_Programs);
   EDJE_STRUCT_APPEND(p, programs, PROGRAM, Edje_Program);
   PROGRAM = NULL;
}
/*
programs_subblock ::= image.
{
   Edje_Programs *p;

   p = PARSER_CURRENT(PROGRAMS, Edje_Programs);
   EDJE_STRUCT_APPEND(p, images, IMAGE, Edje_Image);
   IMAGE = NULL;
}
*/
programs_subblock ::= images.
{
   Edje_Programs *p;

   p = PARSER_CURRENT(PROGRAMS, Edje_Programs);
   EDJE_STRUCT_APPEND(p, imageses, IMAGES, Edje_Images);
   IMAGES = NULL;
}
programs_subblock ::= font.
{
   Edje_Programs *p;

   p = PARSER_CURRENT(PROGRAMS, Edje_Programs);
   EDJE_STRUCT_APPEND(p, fonts, FONT, Edje_Font);
   FONT = NULL;
}
programs_subblock ::= fonts.
{
   Edje_Programs *p;

   p = PARSER_CURRENT(PROGRAMS, Edje_Programs);
   EDJE_STRUCT_APPEND(p, fontses, FONTS, Edje_Fonts);
   FONTS = NULL;
}
/*programs_subblocks ::= set.*/
/******************************** END PROGRAMS CODE **********************************/
/******************************** START PROGRAM CODE **********************************/
program ::= program_start program_blocks.
program_start ::= doc_comment(C) PROGRAM.
{
   Edje_Program *p;

   EDJE_CREATE;   
   p = edje_program_new();
   PARSER_APPEND(PROGRAM, p, Edje_Program);
   DBG("Program: %p", p);
   p->doc = C;
}
program_blocks ::= LB program_subblocks RB.
program_blocks ::= DOT program_subblock.
program_subblocks ::= program_subblocks program_subblock.
program_subblocks ::= program_subblock.

program_subblock ::= script(S).
{
   Edje_Program *p;

   p = PARSER_CURRENT(PROGRAM, Edje_Program);
   p->script = S;
}

program_subblock ::= PROPERTY(P) ID(I) SEMICOLON.
{
   Edje_Program *p;

   p = PARSER_CURRENT(PROGRAM, Edje_Program);
   DBG("Program property - '%s' '%s'", P->text, I->text);
   if (!strcmp(P->text, "name:"))
     STRINGSHARE_REPLACE_NOQUOTES(p->name, I->text);
   else if (!strcmp(P->text, "signal:"))
     STRINGSHARE_REPLACE_NOQUOTES(p->signal, I->text);
   else if (!strcmp(P->text, "source:"))
     STRINGSHARE_REPLACE_NOQUOTES(p->source, I->text);
   else if (!strcmp(P->text, "target:"))
     p->targets = eina_list_append(p->targets, eina_stringshare_add_length(I->text + 1, strlen(I->text + 1) - 1));
   else if (!strcmp(P->text, "after:"))
     p->targets = eina_list_append(p->after, eina_stringshare_add_length(I->text + 1, strlen(I->text + 1) - 1));
   else ERROR_SYNTAX(P);
   edje_parser_token_free(P);
   edje_parser_token_free(I);
}
program_subblock ::= PROPERTY(P) ID(I) ID(J) SEMICOLON.
{
   Edje_Program *p;

   p = PARSER_CURRENT(PROGRAM, Edje_Program);
   DBG("Program property - '%s' '%s' '%s'", P->text, I->text, J->text);
   if (!strcmp(P->text, "api:"))
     {
        STRINGSHARE_REPLACE_NOQUOTES(p->api.name, I->text);
        STRINGSHARE_REPLACE_NOQUOTES(p->api.description, J->text);
     }
   if (!strcmp(P->text, "filter:"))
     {
        STRINGSHARE_REPLACE_NOQUOTES(p->filter.part, I->text);
        STRINGSHARE_REPLACE_NOQUOTES(p->filter.state, J->text);
     }
   else ERROR_SYNTAX(P);
   edje_parser_token_free(P);
   edje_parser_token_free(I);
   edje_parser_token_free(J);
}
program_subblock ::= PROPERTY(P) NUMBER(I) NUMBER(J) SEMICOLON.
{
   Edje_Program *p;

   p = PARSER_CURRENT(PROGRAM, Edje_Program);
   DBG("Program property - '%s' '%s' '%s'", P->text, I->text, J->text);
   if (!strcmp(P->text, "in:"))
     {
        if (!edje_parser_strtod(I->text, &p->in.from))
          ERROR_RANGE(I);
        else if (!edje_parser_strtod(J->text, &p->in.range))
          ERROR_RANGE(J);
     }
   else ERROR_SYNTAX(P);
   edje_parser_token_free(P);
   edje_parser_token_free(I);
   edje_parser_token_free(J);
}
program_subblock ::= PROPERTY(P) CAPS(C) SEMICOLON.
{
   Edje_Program *p;

   p = PARSER_CURRENT(PROGRAM, Edje_Program);
   if (!strcmp(P->text, "action:") && (!p->action.type))
     {
         if (!strcmp(C->text, "ACTION_STOP"))
           p->action.type = EDJE_PROGRAM_ACTION_ACTION_STOP;
         else if (!strcmp(C->text, "FOCUS_SET"))
           p->action.type = EDJE_PROGRAM_ACTION_FOCUS_SET;
         else if (!strcmp(C->text, "FOCUS_OBJECT"))
           p->action.type = EDJE_PROGRAM_ACTION_FOCUS_OBJECT;
         else ERROR_SYNTAX(C);
     }
   else ERROR_SYNTAX(P);
   edje_parser_token_free(P);
   edje_parser_token_free(C);
}
program_subblock ::= PROPERTY(P) CAPS(C) NUMBER(I) NUMBER(J) SEMICOLON.
{
   Edje_Program *p;

   p = PARSER_CURRENT(PROGRAM, Edje_Program);
   if (!strcmp(P->text, "action:") && (!p->action.type))
     {
         if (!strcmp(C->text, "DRAG_VAL_SET"))
           p->action.type = EDJE_PROGRAM_ACTION_DRAG_VAL_SET;
         else if (!strcmp(C->text, "DRAG_VAL_STEP"))
           p->action.type = EDJE_PROGRAM_ACTION_DRAG_VAL_STEP;
         else if (!strcmp(C->text, "DRAG_VAL_PAGE"))
           p->action.type = EDJE_PROGRAM_ACTION_DRAG_VAL_PAGE;

         if (!p->action.type) ERROR_SYNTAX(C);
         else if (!edje_parser_strtof(I->text, (float*)&p->action.params.numbers[0]))
           ERROR_RANGE(I);
         else if (!edje_parser_strtof(J->text, (float*)&p->action.params.numbers[1]))
           ERROR_RANGE(J);
     }
   else ERROR_SYNTAX(P);
   edje_parser_token_free(P);
   edje_parser_token_free(C);
   edje_parser_token_free(I);
   edje_parser_token_free(J);
}
program_subblock ::= PROPERTY(P) CAPS(C) ID(I) NUMBER(J) SEMICOLON.
{
   Edje_Program *p;

   p = PARSER_CURRENT(PROGRAM, Edje_Program);
   if (!strcmp(P->text, "action:") && (!p->action.type))
     {
         if (!strcmp(C->text, "STATE_SET"))
           p->action.type = EDJE_PROGRAM_ACTION_STATE_SET;

         if (!p->action.type) ERROR_SYNTAX(C);
         else if (!edje_parser_strtof(J->text, (float*)&p->action.params.numbers[0]))
           ERROR_RANGE(J);
         else
           p->action.params.strings =
             eina_list_append(p->action.params.strings,
               eina_stringshare_add_length(I->text + 1, strlen(I->text + 1) - 1)
             );
     }
   else ERROR_SYNTAX(P);
   edje_parser_token_free(P);
   edje_parser_token_free(C);
   edje_parser_token_free(I);
   edje_parser_token_free(J);
}
program_subblock ::= PROPERTY(P) CAPS(C) ID(I) ID(J) SEMICOLON.
{
   Edje_Program *p;

   p = PARSER_CURRENT(PROGRAM, Edje_Program);
   if (!strcmp(P->text, "action:") && (!p->action.type))
     {
         if (!strcmp(C->text, "SIGNAL_EMIT"))
           p->action.type = EDJE_PROGRAM_ACTION_SIGNAL_EMIT;

         if (!p->action.type) ERROR_SYNTAX(C);
         else
           {
              p->action.params.strings =
                eina_list_append(p->action.params.strings,
                  eina_stringshare_add_length(I->text + 1, strlen(I->text + 1) - 1)
                );
              p->action.params.strings =
                eina_list_append(p->action.params.strings,
                  eina_stringshare_add_length(J->text + 1, strlen(J->text + 1) - 1)
                );  
           }
     }
   else ERROR_SYNTAX(P);
   edje_parser_token_free(P);
   edje_parser_token_free(C);
   edje_parser_token_free(I);
   edje_parser_token_free(J);
}
program_subblock ::= PROPERTY(P) CAPS(C) ID(I) ID(J) ID(K) SEMICOLON.
{
   Edje_Program *p;

   p = PARSER_CURRENT(PROGRAM, Edje_Program);
   if (!strcmp(P->text, "action:") && (!p->action.type))
     {
         if (!strcmp(C->text, "PARAM_SET"))
           p->action.type = EDJE_PROGRAM_ACTION_PARAM_SET;

         if (!p->action.type) ERROR_SYNTAX(C);
         else
           {
              p->action.params.strings =
                eina_list_append(p->action.params.strings,
                  eina_stringshare_add_length(I->text + 1, strlen(I->text + 1) - 1)
                );
              p->action.params.strings =
                eina_list_append(p->action.params.strings,
                  eina_stringshare_add_length(J->text + 1, strlen(J->text + 1) - 1)
                );
              p->action.params.strings =
                eina_list_append(p->action.params.strings,
                  eina_stringshare_add_length(K->text + 1, strlen(K->text + 1) - 1)
                );
           }
     }
   else ERROR_SYNTAX(P);
   edje_parser_token_free(P);
   edje_parser_token_free(C);
   edje_parser_token_free(I);
   edje_parser_token_free(J);
   edje_parser_token_free(K);
}
program_subblock ::= PROPERTY(P) CAPS(C) ID(I) ID(J) ID(K) ID(L) SEMICOLON.
{
   Edje_Program *p;

   p = PARSER_CURRENT(PROGRAM, Edje_Program);
   if (!strcmp(P->text, "action:") && (!p->action.type))
     {
         if (!strcmp(C->text, "PARAM_COPY"))
           p->action.type = EDJE_PROGRAM_ACTION_PARAM_COPY;

         if (!p->action.type) ERROR_SYNTAX(C);
         else
           {
              p->action.params.strings =
                eina_list_append(p->action.params.strings,
                  eina_stringshare_add_length(I->text + 1, strlen(I->text + 1) - 1)
                );
              p->action.params.strings =
                eina_list_append(p->action.params.strings,
                  eina_stringshare_add_length(J->text + 1, strlen(J->text + 1) - 1)
                );
              p->action.params.strings =
                eina_list_append(p->action.params.strings,
                  eina_stringshare_add_length(K->text + 1, strlen(K->text + 1) - 1)
                );
              p->action.params.strings =
                eina_list_append(p->action.params.strings,
                  eina_stringshare_add_length(L->text + 1, strlen(L->text + 1) - 1)
                );
           }
     }
   else ERROR_SYNTAX(P);
   edje_parser_token_free(P);
   edje_parser_token_free(C);
   edje_parser_token_free(I);
   edje_parser_token_free(J);
   edje_parser_token_free(K);
   edje_parser_token_free(L);
}
program_subblock ::= PROPERTY(P) CAPS(C) NUMBER(I) SEMICOLON.
{
   Edje_Program *p;

   p = PARSER_CURRENT(PROGRAM, Edje_Program);
   if (!strcmp(P->text, "transition:") && (!p->action.transition.length) && (!p->action.transition.type)) /* error on double set */
     {
#define EDJE_ACTION_CHECK(NAME) \
  if (!strcmp(C->text, #NAME)) \
    p->action.transition.type = EDJE_PROGRAM_TRANSITION_##NAME

        EDJE_ACTION_CHECK(LINEAR);
        else EDJE_ACTION_CHECK(SINUSOIDAL);
        else EDJE_ACTION_CHECK(ACCELERATE);
        else EDJE_ACTION_CHECK(DECELERATE);
        
        if (!p->action.transition.type)
          ERROR_SYNTAX(I);
        else if (!edje_parser_strtof(I->text, (float*)&p->action.transition.length))
          ERROR_RANGE(I);
#undef EDJE_ACTION_CHECK
     }
   else ERROR_SYNTAX(P);
   edje_parser_token_free(P);
   edje_parser_token_free(C);
   edje_parser_token_free(I);
}
/******************************** END PROGRAM CODE **********************************/
/******************************* START IMAGES CODE *********************************/

images ::= images_start images_blocks.
images_start ::= doc_comment(C) IMAGES.
{
   Edje_Images *i;

   EDJE_CREATE;   
   i = edje_images_new();
   PARSER_APPEND(IMAGES, i, Edje_Images);
   DBG("Images: %p", i);
   i->doc = C;
}
images_blocks ::= LB images_subblocks RB.
images_blocks ::= DOT images_subblock.
images_subblocks ::= images_subblocks images_subblock.
images_subblocks ::= images_subblock.

images_subblock ::= images_image_start compression SEMICOLON.
{
   Edje_Images *i;

   i = PARSER_CURRENT(IMAGES, Edje_Images);
   EDJE_STRUCT_APPEND(i, set_images, SET_IMAGE, Edje_Set_Image);
   SET_IMAGE = NULL;
}
images_image_start ::= PROPERTY(P) ID(I).
{
   Edje_Set_Image *s;

   if (strcmp(P->text, "image:"))
     {
        ERROR_SYNTAX(P);
        goto images_image_out;
     }
   if (strchr(I->text, ':')) // invalid filename characters
     {
        ERROR_SYNTAX(I);
        goto images_image_out;
     }
   EDJE_CREATE;
   s = edje_set_image_new();
   PARSER_APPEND(SET_IMAGE, s, Edje_Set_Image);
   DBG("Set image: %p", s);
   STRINGSHARE_REPLACE_NOQUOTES(s->filename, I->text);

images_image_out:
   edje_parser_token_free(P);
   edje_parser_token_free(I);
}

compression ::= RAW.
{
   Edje_Set_Image *i;

   i = PARSER_CURRENT(SET_IMAGE, Edje_Set_Image);
   i->comp = EDJE_COMPRESSION_TYPE_RAW;
}
compression ::= COMP.
{
   Edje_Set_Image *i;

   i = PARSER_CURRENT(SET_IMAGE, Edje_Set_Image);
   i->comp = EDJE_COMPRESSION_TYPE_COMP;
}
compression ::= LOSSY D(I).
{
   Edje_Set_Image *i;
   int num;

   if (strchr(I->text, '.') || (!edje_parser_strtol(I->text, &num)) || (num < 0) || (num > 100))
     {
        ERROR_RANGE(I);
        goto compression_out;
     }
   i = PARSER_CURRENT(SET_IMAGE, Edje_Set_Image);
   i->comp = EDJE_COMPRESSION_TYPE_LOSSY;
   i->comp_amount = num;

compression_out:
   edje_parser_token_free(I);
}
compression ::= USER.
{
   Edje_Set_Image *i;

   i = PARSER_CURRENT(SET_IMAGE, Edje_Set_Image);
   i->comp = EDJE_COMPRESSION_TYPE_USER;
}

/******************************* END IMAGES CODE *********************************/
/******************************* START GROUPS CODE *********************************/
%type group {Edje_Group *}
group ::= group_start group_block.
group_start ::= doc_comment(C) GROUP.
{
   Edje_Group *g;

   EDJE_CREATE;   
   g = edje_group_new();
   PARSER_APPEND(GROUP, g, Edje_Group);
   DBG("Group: %p", g);
   g->doc = C;
}
group_block ::= LB group_subblocks RB.
group_block ::= DOT group_subblock.

/*************************** GROUP SUB-BLOCKS ************************************/
group_subblocks ::= group_subblocks group_subblock.
group_subblocks ::= group_subblock.

group_subblock ::= color_classes.
{
   Edje_Group *g;

   g = PARSER_CURRENT(GROUP, Edje_Group);
   EDJE_STRUCT_APPEND(g, color_classes, COLOR_CLASS, Edje_Color_Class);
   COLOR_CLASS = NULL;
}
group_subblock ::= images.
{
   Edje_Group *g;

   g = PARSER_CURRENT(GROUP, Edje_Group);
   EDJE_STRUCT_APPEND(g, imageses, IMAGES, Edje_Images);
   IMAGES = NULL;
}
group_subblock ::= fonts.
{
   Edje_Group *g;

   g = PARSER_CURRENT(GROUP, Edje_Group);
   EDJE_STRUCT_APPEND(g, fontses, FONTS, Edje_Fonts);
   FONTS = NULL;
}
group_subblock ::= font.
{
   Edje_Group *g;

   g = PARSER_CURRENT(GROUP, Edje_Group);
   EDJE_STRUCT_APPEND(g, fonts, FONT, Edje_Font);
   FONT = NULL;
}
group_subblock ::= programs.
{
   Edje_Group *g;

   g = PARSER_CURRENT(GROUP, Edje_Group);
   EDJE_STRUCT_APPEND(g, programses, PROGRAMS, Edje_Programs);
   PROGRAMS = NULL;
}
group_subblock ::= program.
{
   Edje_Group *g;

   g = PARSER_CURRENT(GROUP, Edje_Group);
   EDJE_STRUCT_APPEND(g, programs, PROGRAM, Edje_Program);
   PROGRAM = NULL;
}
group_subblock ::= externals.
{
   Edje_Group *g;

   g = PARSER_CURRENT(GROUP, Edje_Group);
   EDJE_STRUCT_APPEND(g, externals, EXTERNAL, Edje_External);
   EXTERNAL = NULL;
}
group_subblock ::= script(S).
{
   Edje_Group *g;

   g = PARSER_CURRENT(GROUP, Edje_Group);
   g->script = S;
}
group_subblock ::= parts.
{
   Edje_Group *g;

   g = PARSER_CURRENT(GROUP, Edje_Group);
   g->parts = PARTS; /* there can only be one parts{} in a group */
   PARTS = NULL;
}

group_subblock ::= group_property.
/*************************** END GROUP SUB-BLOCKS ********************************/
/*************************** GROUP PROPERTY BLOCKS *******************************/
group_property ::= PROPERTY(P) ID(I) SEMICOLON. /* property: "value"; */
{
   Edje_Group *g;

   g = PARSER_CURRENT(GROUP, Edje_Group);
   DBG("Group property - '%s':'%s'", P->text, I->text);
   if (!strcmp(P->text, "alias:"))
     STRINGSHARE_REPLACE_NOQUOTES(g->alias, I->text);
   else if (!strcmp(P->text, "name:"))
     STRINGSHARE_REPLACE_NOQUOTES(g->name, I->text);
   else
     ERROR_SYNTAX(P);

   edje_parser_token_free(P);
   edje_parser_token_free(I);
}
group_property ::= PROPERTY(P) NUMBER(I) SEMICOLON. /* property: bool */
{
   Edje_Group *g;
   int i;

   g = PARSER_CURRENT(GROUP, Edje_Group);
   DBG("Group property - '%s':'%s'", P->text, I->text);
   if (strcmp(P->text, "script_only:"))
     {
        ERROR_SYNTAX(P);
        goto group_property_bool_out;
     }
   if (!edje_parser_strtobool(I->text, &i))
     {
        ERROR_RANGE(I);
        goto group_property_bool_out;
     }
   g->script_only = !!i;

group_property_bool_out:
   edje_parser_token_free(P);
   edje_parser_token_free(I);
}

group_property ::= PROPERTY(P) NUMBER(I) NUMBER(J) SEMICOLON. /* property: int int */
{
   Edje_Group *g;

   g = PARSER_CURRENT(GROUP, Edje_Group);
   DBG("Property: '%s'", P->text);
   if (!strcmp(P->text, "min:"))
     {
        if (!edje_parser_parse_min(ep, I, J, g->min, g->max))
          goto group_property_int_out;
     }
   else if (!strcmp(P->text, "max:"))
     {
        if (!edje_parser_parse_max(ep, I, J, g->min, g->max))
          goto group_property_int_out;
     }
   else
     ERROR_SYNTAX(P);
     
group_property_int_out:
   edje_parser_token_free(P);
   edje_parser_token_free(I);
   edje_parser_token_free(J);
}
/*************************** END GROUP PROPERTY BLOCKS ***************************/
/******************************* END GROUPS CODE *********************************/
/******************************* START PARTS CODE ********************************/
parts ::= parts_start parts_block.
parts_start ::= doc_comment(C) PARTS.
{
   Edje_Parts *p;

   EDJE_CREATE;
   p = edje_parts_new();
   PARTS = p; // there can only be one at a time
   DBG("Parts: %p", p);
   p->doc = C;
}
parts_block ::= LB parts_subblocks RB.
/******************************* PARTS SUB-BLOCKS ********************************/
parts_subblocks ::= parts_subblocks parts_subblock.
parts_subblocks ::= parts_subblock.

parts_subblock ::= fonts.
{
   EDJE_STRUCT_APPEND(PARTS, fontses, FONTS, Edje_Fonts);
   FONTS = NULL;
}
parts_subblock ::= font.
{
   EDJE_STRUCT_APPEND(PARTS, fonts, FONT, Edje_Font);
   FONT = NULL;
}
parts_subblock ::= programs.
{
   EDJE_STRUCT_APPEND(PARTS, programses, PROGRAMS, Edje_Programs);
   PROGRAMS = NULL;
}
parts_subblock ::= program.
{
   EDJE_STRUCT_APPEND(PARTS, programs, PROGRAM, Edje_Program);
   PROGRAM = NULL;
}
parts_subblock ::= color_classes.
{
   EDJE_STRUCT_APPEND(PARTS, color_classes, COLOR_CLASS, Edje_Color_Class);
   COLOR_CLASS = NULL;
}
parts_subblock ::= images.
{
   EDJE_STRUCT_APPEND(PARTS, imageses, IMAGES, Edje_Images);
   IMAGES = NULL;
}
parts_subblock ::= part.
{
   EDJE_STRUCT_APPEND(PARTS, parts, PART, Edje_Part);
   PART = NULL;
}
parts_subblock ::= script(S).
{
   PARTS->script = S;
}
parts_subblock ::= parts_property.
parts_property ::= PROPERTY(P) ID(A) ID(B).
{
   const char *b;
   char *a;
   if (strcmp(P->text, "aliases"))
     {
        ERROR_SYNTAX(P);
        goto parts_property_out;
     }

   a = strndupa(A->text + 1, strlen(A->text + 1) - 1);
   STRINGSHARE_REPLACE_NOQUOTES(b, B->text);

parts_property_out:
   edje_parser_token_free(P);
   edje_parser_token_free(A);
   edje_parser_token_free(B);
}
/*
parts_subblock ::= sets.
parts_subblock ::= styles.
*/
/*************************** END PARTS SUB-BLOCKS *******************************/
/******************************* END PARTS CODE *********************************/

/******************************* START PART CODE ********************************/
part ::= part_start part_block.
part_start ::= doc_comment(C) PART.
{
   Edje_Part *p;

   EDJE_CREATE;
   p = edje_part_new();
   PARSER_APPEND(PART, p, Edje_Part);
   DBG("Part: %p", p);
   p->doc = C;
}
part_block ::= LB part_subblocks RB.
/******************************* PART SUB-BLOCKS ********************************/
part_subblocks ::= part_subblocks part_subblock.
part_subblocks ::= part_subblock.

part_subblock ::= fonts.
{
   Edje_Part *p;

   p = PARSER_CURRENT(PART, Edje_Part);
   EDJE_STRUCT_APPEND(p, fontses, FONTS, Edje_Fonts);
   FONTS = NULL;
}
part_subblock ::= font.
{
   Edje_Part *p;

   p = PARSER_CURRENT(PART, Edje_Part);
   EDJE_STRUCT_APPEND(p, fonts, FONT, Edje_Font);
   FONT = NULL;
}
part_subblock ::= programs.
{
   Edje_Part *p;

   p = PARSER_CURRENT(PART, Edje_Part);
   EDJE_STRUCT_APPEND(p, programses, PROGRAMS, Edje_Programs);
   PROGRAMS = NULL;
}
part_subblock ::= program.
{
   Edje_Part *p;

   p = PARSER_CURRENT(PART, Edje_Part);
   EDJE_STRUCT_APPEND(p, programs, PROGRAM, Edje_Program);
   PROGRAM = NULL;
}
part_subblock ::= color_classes.
{
   Edje_Part *p;

   p = PARSER_CURRENT(PART, Edje_Part);
   EDJE_STRUCT_APPEND(p, color_classes, COLOR_CLASS, Edje_Color_Class);
   COLOR_CLASS = NULL;
}
part_subblock ::= images.
{
   Edje_Part *p;

   p = PARSER_CURRENT(PART, Edje_Part);
   EDJE_STRUCT_APPEND(p, imageses, IMAGES, Edje_Images);
   IMAGES = NULL;
}
part_subblock ::= script(S).
{
   Edje_Part *p;

   p = PARSER_CURRENT(PART, Edje_Part);
   p->script = S;
}
part_subblock ::= part_description.
{
   Edje_Part *p;

   p = PARSER_CURRENT(PART, Edje_Part);
   EDJE_STRUCT_APPEND(p, descriptions, DESCRIPTION, Edje_Part_Description);
   DESCRIPTION = NULL;
}

/************************** START DESCRIPTION CODE ******************************/
part_description ::= part_description_start part_description_block.
part_description_start ::= doc_comment(C) DESCRIPTION.
{
   Edje_Part_Description *p;

   EDJE_CREATE;
   p = edje_part_description_new();
   PARSER_APPEND(DESCRIPTION, p, Edje_Part_Description);
   DBG("Part_Description: %p", p);
   p->doc = C;
}
part_description_block ::= LB part_description_subblocks RB.
part_description_block ::= DOT part_description_subblock.
/******************************* DESC SUB-BLOCKS ********************************/
part_description_subblocks ::= part_description_subblocks part_description_subblock.
part_description_subblocks ::= part_description_subblock.

part_description_subblock ::= color_classes.
{
   Edje_Part_Description *p;

   p = PARSER_CURRENT(DESCRIPTION, Edje_Part_Description);
   EDJE_STRUCT_APPEND(p, color_classes, COLOR_CLASS, Edje_Color_Class);
   COLOR_CLASS = NULL;
}
part_description_subblock ::= images.
{
   Edje_Part_Description *p;

   p = PARSER_CURRENT(DESCRIPTION, Edje_Part_Description);
   EDJE_STRUCT_APPEND(p, imageses, IMAGES, Edje_Images);
   IMAGES = NULL;
}
part_description_subblock ::= fonts.
{
   Edje_Part_Description *p;

   p = PARSER_CURRENT(DESCRIPTION, Edje_Part_Description);
   EDJE_STRUCT_APPEND(p, fontses, FONTS, Edje_Fonts);
   FONTS = NULL;
}
part_description_subblock ::= font.
{
   Edje_Part_Description *p;

   p = PARSER_CURRENT(DESCRIPTION, Edje_Part_Description);
   EDJE_STRUCT_APPEND(p, fonts, FONT, Edje_Font);
   FONT = NULL;
}
part_description_subblock ::= programs.
{
   Edje_Part_Description *p;

   p = PARSER_CURRENT(DESCRIPTION, Edje_Part_Description);
   EDJE_STRUCT_APPEND(p, programses, PROGRAMS, Edje_Programs);
   PROGRAMS = NULL;
}
part_description_subblock ::= program.
{
   Edje_Part_Description *p;

   p = PARSER_CURRENT(DESCRIPTION, Edje_Part_Description);
   EDJE_STRUCT_APPEND(p, programs, PROGRAM, Edje_Program);
   PROGRAM = NULL;
}
part_description_subblock ::= script(S).
{
   Edje_Part_Description *p;

   p = PARSER_CURRENT(DESCRIPTION, Edje_Part_Description);
   p->script = S;
}
/*************************************** PROPERTY ************************************/
part_description_subblock ::= part_description_property.
part_description_property ::= PROPERTY(P) ID(I) SEMICOLON.
{
    Edje_Part_Description *p;

    p = PARSER_CURRENT(DESCRIPTION, Edje_Part_Description);
    DBG("Desc property - '%s':'%s'", P->text, I->text);

    if (!strcmp(P->text, "color_class:"))
      STRINGSHARE_REPLACE_NOQUOTES(p->color_class, I->text);
   else ERROR_SYNTAX(P);

   edje_parser_token_free(P);
   edje_parser_token_free(I);
}
part_description_property ::= PROPERTY(P) CAPS(I) SEMICOLON.
{
    Edje_Part_Description *p;

    p = PARSER_CURRENT(DESCRIPTION, Edje_Part_Description);
    DBG("Desc property - '%s':'%s'", P->text, I->text);

    if (!strcmp(P->text, "aspect_preference:"))
      {
         if (!strcmp(I->text, "BOTH"))
           p->aspect_preference = EDJE_PART_DESCRIPTION_ASPECT_PREF_BOTH;
         else if (!strcmp(I->text, "VERTICAL"))
           p->aspect_preference = EDJE_PART_DESCRIPTION_ASPECT_PREF_VERTICAL;
         else if (!strcmp(I->text, "HORIZONTAL"))
           p->aspect_preference = EDJE_PART_DESCRIPTION_ASPECT_PREF_HORIZONTAL;
         else if (!strcmp(I->text, "NONE"))
           p->aspect_preference = EDJE_PART_DESCRIPTION_ASPECT_PREF_NONE;
         else ERROR_SYNTAX(I);
      }
   else ERROR_SYNTAX(P);

   edje_parser_token_free(P);
   edje_parser_token_free(I);
}
part_description_property ::= PROPERTY(P) NUMBER(I) SEMICOLON.
{
    Edje_Part_Description *p;
    int i;

    p = PARSER_CURRENT(DESCRIPTION, Edje_Part_Description);
    DBG("Desc property - '%s':'%s'", P->text, I->text);

   if (!edje_parser_strtobool(I->text, &i))
     {
        ERROR_RANGE(I);
        goto part_description_property_bool_out;
     }

   if (!strcmp(P->text, "visible:"))
     p->visible = !!i;
   else ERROR_SYNTAX(P);

part_description_property_bool_out:
   edje_parser_token_free(P);
   edje_parser_token_free(I);
}
part_description_property ::= PROPERTY(P) ID(I) NUMBER(D) SEMICOLON.
{
    Edje_Part_Description *p;
    float d;

    p = PARSER_CURRENT(DESCRIPTION, Edje_Part_Description);
    DBG("Desc property - '%s':'%s %s'", P->text, I->text, D->text);

    if (!edje_parser_strtof(D->text, &d))
      {
         ERROR_RANGE(D);
         goto part_description_property_state_out;
      }

    if (!strcmp(P->text, "inherit:"))
      {
         STRINGSHARE_REPLACE_NOQUOTES(p->inherit.name, I->text);
         p->inherit.index = d;
      }
    else if (!strcmp(P->text, "state:"))
      {
         STRINGSHARE_REPLACE_NOQUOTES(p->state.name, I->text);
         p->state.index = d;
      }
    else ERROR_SYNTAX(P);

part_description_property_state_out:
    edje_parser_token_free(P);
    edje_parser_token_free(I);
    edje_parser_token_free(D);
}
part_description_property ::= PROPERTY(P) NUMBER(I) NUMBER(J) SEMICOLON.
{
    Edje_Part_Description *p;
    int i, j;

    p = PARSER_CURRENT(DESCRIPTION, Edje_Part_Description);
    DBG("Desc property - '%s':'%s %s'", P->text, I->text, J->text);

   if (!strcmp(P->text, "fixed:"))
     {
        if (!edje_parser_strtobool(I->text, &i))
          {
             ERROR_RANGE(I);
             goto part_desc_subblock_bool_out;
          }
        if (!edje_parser_strtobool(J->text, &j))
          {
             ERROR_RANGE(J);
             goto part_desc_subblock_bool_out;
          }
        p->fixed[0] = !!i;
        p->fixed[1] = !!j;
     }
   else if (!strcmp(P->text, "align:"))
     {
        if (!edje_parser_strtof(I->text, &p->align[0]))
          ERROR_RANGE(I);
        if (!edje_parser_strtof(J->text, &p->align[1]))
          ERROR_RANGE(J);
     }
   else if (!strcmp(P->text, "aspect:"))
     {
        if (!edje_parser_strtof(I->text, &p->aspect[0]))
          ERROR_RANGE(I);
        if (!edje_parser_strtof(J->text, &p->aspect[1]))
          ERROR_RANGE(J);
     }
   else if (!strcmp(P->text, "min:"))
     edje_parser_parse_min(ep, I, J, p->min, p->max);
   else if (!strcmp(P->text, "max:"))
     edje_parser_parse_max(ep, I, J, p->min, p->max);
   else if (!strcmp(P->text, "step:"))
     {
        if (strchr(I->text, '.') || (!edje_parser_strtol(I->text, &i) || (i < 0)))
          {
             ERROR_RANGE(I);
             goto part_desc_subblock_bool_out;
          }
        if (strchr(J->text, '.') || !edje_parser_strtol(J->text, &j) || (j < 0))
          {
             ERROR_RANGE(J);
             goto part_desc_subblock_bool_out;
          }
        p->step[0] = i;
        p->step[1] = j;
     }
   else ERROR_SYNTAX(P);
part_desc_subblock_bool_out:
   edje_parser_token_free(P);
   edje_parser_token_free(I);
   edje_parser_token_free(J);
}
part_description_property ::= PROPERTY(P) NUMBER(I) NUMBER(J) NUMBER(K) NUMBER(L) SEMICOLON.
{
   Edje_Part_Description *p;
   int *colors[3];
   Edje_Token *tokens[4];

   p = PARSER_CURRENT(DESCRIPTION, Edje_Part_Description);
   DBG("Part desc property: %s:%s %s %s %s", P->text, I->text, J->text, K->text, L->text);
   tokens[0] = I;
   tokens[1] = J;
   tokens[2] = K;
   tokens[3] = L;
   colors[0] = p->color;
   colors[1] = p->color2;
   colors[2] = p->color3;
   if (!edje_parser_parse_color(ep, P, (Edje_Token**)tokens, (int**)colors) && (!ep->error))
     ERROR_SYNTAX(P);

   edje_parser_token_free(P);
   edje_parser_token_free(I);
   edje_parser_token_free(J);
   edje_parser_token_free(K);
   edje_parser_token_free(L);
}
/*************************************** PARAMS ******************************************/
part_description_subblock ::= part_description_params.
part_description_params ::= part_description_params_start part_description_params_block.
part_description_params_start ::= PARAMS.
part_description_params_block ::= LB part_description_params_subblocks RB.
part_description_params_block ::= DOT part_description_params_subblock.
part_description_params_subblocks ::= part_description_params_subblocks part_description_params_subblock.
part_description_params_subblocks ::= part_description_params_subblock.

part_description_params_subblock ::= part_description_param.
part_description_param ::= PROPERTY(P) ID(I) ID(J) SEMICOLON.
{
   Edje_Part_Description *p;
   Edje_Param *e;
   Eina_Bool str = EINA_FALSE;

   if (!strcmp(P->text, "string:"))
     str = EINA_TRUE;
   else if (strcmp(P->text, "choice:"))
     {
        ERROR_SYNTAX(P);
        goto part_description_param_str_out;
     }

   p = PARSER_CURRENT(DESCRIPTION, Edje_Part_Description);
   e = edje_param_new();
   if (str)
     e->type = EDJE_PARAM_TYPE_STRING;
   else
     e->type = EDJE_PARAM_TYPE_CHOICE;

   STRINGSHARE_REPLACE_NOQUOTES(e->data.s, J->text);
   eina_hash_add(p->params, I->text, e);

part_description_param_str_out:
   edje_parser_token_free(P);
   edje_parser_token_free(I);
   edje_parser_token_free(J);
}
part_description_param ::= PROPERTY(P) ID(I) NUMBER(J) SEMICOLON.
{
   Edje_Part_Description *p;
   Edje_Param *e;
   int i;

   if (!strcmp(P->text, "int:"))
     i = 0;
   else if (!strcmp(P->text, "double:"))
     i = 1;
   else if (!strcmp(P->text, "bool:"))
     i = 2;
   else
     {
        ERROR_SYNTAX(P);
        goto part_description_param_num_out;
     }

   p = PARSER_CURRENT(DESCRIPTION, Edje_Part_Description);
   e = edje_param_new();
   switch (i)
     {
      case 0:
        e->type = EDJE_PARAM_TYPE_INT;
        if (!edje_parser_strtol(J->text, &e->data.i))
          {
             free(e);
             ERROR_RANGE(J);
             goto part_description_param_num_out;
          }
        break;
      case 1:
        e->type = EDJE_PARAM_TYPE_DOUBLE;
        if (!edje_parser_strtod(J->text, &e->data.d))
          {
             free(e);
             ERROR_RANGE(J);
             goto part_description_param_num_out;
          }
        break;
      case 2:
        e->type = EDJE_PARAM_TYPE_BOOL;
        if (!edje_parser_strtobool(J->text, &i))
          {
             free(e);
             ERROR_RANGE(J);
             goto part_description_param_num_out;
          }
        e->data.b = !!i;
        break;
     }
   eina_hash_add(p->params, I->text, e);

part_description_param_num_out:
   edje_parser_token_free(P);
   edje_parser_token_free(I);
   edje_parser_token_free(J);
}
/************************************ PERSPECTIVE ****************************************/
part_description_subblock ::= part_description_perspective.
part_description_perspective ::= part_description_perspective_start part_description_perspective_block.
part_description_perspective_start ::= PERSPECTIVE.
part_description_perspective_block ::= LB part_description_perspective_subblocks RB.
part_description_perspective_block ::= DOT part_description_perspective_subblock.
part_description_perspective_subblocks ::= part_description_perspective_subblocks part_description_perspective_subblock.
part_description_perspective_subblocks ::= part_description_perspective_subblock.
part_description_perspective_subblock ::= PROPERTY(P) NUMBER(I) SEMICOLON.
{
   Edje_Part_Description *p;

   p = PARSER_CURRENT(DESCRIPTION, Edje_Part_Description);
   if (!strcmp(P->text, "zplane:"))
     {
        if (strchr(I->text, '.') || (!edje_parser_strtol(I->text, &p->perspective.zplane)))
          ERROR_RANGE(I);
     }
   else if (!strcmp(P->text, "focal:"))
     {
        if (strchr(I->text, '.') || (!edje_parser_strtol(I->text, &p->perspective.focal)))
          ERROR_RANGE(I);
     }
   else ERROR_SYNTAX(P);

   edje_parser_token_free(P);
   edje_parser_token_free(I);
}
/***************************************** TEXT ******************************************/
part_description_subblock ::= part_description_text.
part_description_text ::= part_description_text_start part_description_text_block.
part_description_text_start ::= TEXT(T).
{
   Edje_Part *p;

   p = PARSER_CURRENT(PART, Edje_Part);
   if (p->type != EDJE_PART_TYPE_TEXT)
     ERROR_TYPE(T);
   edje_parser_token_free(T);
}
part_description_text_block ::= LB part_description_text_props RB.
part_description_text_block ::= DOT part_description_text_prop.
part_description_text_props ::= part_description_text_props part_description_text_prop.
part_description_text_props ::= part_description_text_prop.
part_description_text_prop ::= PROPERTY(P) NUMBER(I) SEMICOLON.
{
   Edje_Part_Description *p;

   p = PARSER_CURRENT(DESCRIPTION, Edje_Part_Description);
   if (!strcmp(P->text, "size:"))
     {
        if (strchr(I->text, '.') || (!edje_parser_strtol(I->text, &p->type.text.size) || (p->type.text.size < 1)))
          ERROR_RANGE(I);
     }
   else if (!strcmp(P->text, "elipsis:"))
     {
        if (!edje_parser_strtof(I->text, &p->type.text.elipsis))
          ERROR_RANGE(I);
     }
   else ERROR_SYNTAX(P);

   edje_parser_token_free(P);
   edje_parser_token_free(I);
}
part_description_text_prop ::= PROPERTY(P) NUMBER(I) NUMBER(J) SEMICOLON.
{
   Edje_Part_Description *p;
   int i, j;

   p = PARSER_CURRENT(DESCRIPTION, Edje_Part_Description);
#define EDJE_DESC_CHECK(NAME) \
   if (!strcmp(P->text, #NAME":")) \
     do { \
        if (!edje_parser_strtobool(I->text, &i)) \
          ERROR_RANGE(I); \
        if (!edje_parser_strtobool(J->text, &j)) \
          ERROR_RANGE(J); \
        p->type.text.NAME[0] = !!i; \
        p->type.text.NAME[1] = !!j; \
     } while (0)

   EDJE_DESC_CHECK(fit);
   else EDJE_DESC_CHECK(min);
   else EDJE_DESC_CHECK(max);
   else if (!strcmp(P->text, "align:"))
     {
        if (!edje_parser_strtof(I->text, &p->type.text.align[0]))
          ERROR_RANGE(I);
        if (!edje_parser_strtof(J->text, &p->type.text.align[1]))
          ERROR_RANGE(J);
     }
   else ERROR_SYNTAX(P);
#undef EDJE_DESC_CHECK
   edje_parser_token_free(P);
   edje_parser_token_free(I);
   edje_parser_token_free(J);
}
part_description_text_prop ::= PROPERTY(P) ID(I) SEMICOLON.
{
   Edje_Part_Description *p;

   p = PARSER_CURRENT(DESCRIPTION, Edje_Part_Description);
#define EDJE_DESC_CHECK(NAME) \
   if (!strcmp(P->text, #NAME":")) \
     STRINGSHARE_REPLACE_NOQUOTES(p->type.text.NAME, I->text)
     
   EDJE_DESC_CHECK(text_class);
   else EDJE_DESC_CHECK(text);
   else EDJE_DESC_CHECK(font);
   else EDJE_DESC_CHECK(source);
   else EDJE_DESC_CHECK(text_source);
   else EDJE_DESC_CHECK(style);
   else EDJE_DESC_CHECK(repch);
   else ERROR_SYNTAX(P);
   
#undef EDJE_DESC_CHECK
   edje_parser_token_free(P);
   edje_parser_token_free(I);
}
/******************************************** MAP ***************************************/
part_description_subblock ::= part_description_map.
part_description_map ::= part_description_map_start part_description_map_block.
part_description_map_start ::= MAP.
part_description_map_block ::= LB part_description_map_props RB.
part_description_map_block ::= DOT part_description_map_prop.
part_description_map_props ::= part_description_map_props part_description_map_prop.
part_description_map_props ::= part_description_map_prop.
part_description_map_prop ::= PROPERTY(P) ID(I) SEMICOLON.
{
   Edje_Part_Description *p;

   p = PARSER_CURRENT(DESCRIPTION, Edje_Part_Description);
   if (!strcmp(P->text, "perspective:"))
     STRINGSHARE_REPLACE_NOQUOTES(p->type.map.perspective, I->text);
   else if (!strcmp(P->text, "light:"))
     STRINGSHARE_REPLACE_NOQUOTES(p->type.map.light, I->text);
   else ERROR_SYNTAX(P);

   edje_parser_token_free(P);
   edje_parser_token_free(I);
}
part_description_map_prop ::= PROPERTY(P) NUMBER(I) SEMICOLON.
{
   Edje_Part_Description *p;
   int i;

   p = PARSER_CURRENT(DESCRIPTION, Edje_Part_Description);
#define EDJE_MAP_CHECK(NAME) \
   if (!strcmp(P->text, #NAME":")) \
     do { \
        if (!edje_parser_strtobool(I->text, &i)) \
          ERROR_RANGE(I); \
        else \
          p->type.map.NAME = !!i; \
     } while (0)

   EDJE_MAP_CHECK(on);
   else EDJE_MAP_CHECK(smooth);
   else EDJE_MAP_CHECK(alpha);
   else EDJE_MAP_CHECK(backface_cull);
   else EDJE_MAP_CHECK(perspective_on);
   else ERROR_SYNTAX(P);
#undef EDJE_MAP_CHECK
   edje_parser_token_free(P);
   edje_parser_token_free(I);
}
part_description_map_prop ::= part_description_map_rotation.
part_description_map_rotation ::= part_description_map_rotation_start part_description_map_rotation_block.
part_description_map_rotation_start ::= ROTATION.
part_description_map_rotation_block ::= LB part_description_map_rotation_subblocks RB.
part_description_map_rotation_block ::= DOT part_description_map_rotation_subblock.
part_description_map_rotation_subblocks ::= part_description_map_rotation_subblocks part_description_map_rotation_subblock.
part_description_map_rotation_subblocks ::= part_description_map_rotation_subblock.
part_description_map_rotation_subblock ::= PROPERTY(P) ID(I) SEMICOLON.
{
   Edje_Part_Description *p;

   p = PARSER_CURRENT(DESCRIPTION, Edje_Part_Description);
   if (!strcmp(P->text, "center:"))
     STRINGSHARE_REPLACE_NOQUOTES(p->type.map.rotation.center, I->text);
   else ERROR_SYNTAX(P);

   edje_parser_token_free(P);
   edje_parser_token_free(I);
}
part_description_map_rotation_subblock ::= PROPERTY(P) NUMBER(I) SEMICOLON.
{
   Edje_Part_Description *p;

   p = PARSER_CURRENT(DESCRIPTION, Edje_Part_Description);
#define EDJE_MAP_CHECK(NAME) \
   if (!strcmp(P->text, #NAME":")) \
     do { \
        if (!edje_parser_strtof(I->text, &p->type.map.rotation.NAME)) \
          ERROR_RANGE(I); \
     } while (0)

   EDJE_MAP_CHECK(x);
   else EDJE_MAP_CHECK(y);
   else EDJE_MAP_CHECK(z);
   else ERROR_SYNTAX(P);

   edje_parser_token_free(P);
   edje_parser_token_free(I);
}

/***************************************** REL1/REL2 ************************************/
part_description_subblock ::= part_description_relone. { REL = NULL; }
part_description_subblock ::= part_description_reltwo. { REL = NULL; }
part_description_relone ::= part_description_relone_start part_description_rel_props.
part_description_reltwo ::= part_description_reltwo_start part_description_rel_props.
part_description_relone_start ::= REL1.
{
   Edje_Part_Description *p;

   p = PARSER_CURRENT(DESCRIPTION, Edje_Part_Description);
   DBG("Rel1");
   REL = &p->rel[0];
}
part_description_reltwo_start ::= REL2.
{
   Edje_Part_Description *p;

   p = PARSER_CURRENT(DESCRIPTION, Edje_Part_Description);
   DBG("Rel2");
   REL = &p->rel[1];
}
part_description_rel_props ::= LB relative_properties RB.
part_description_rel_props ::= DOT relative_property.
relative_properties ::= relative_properties relative_property.
relative_properties ::= relative_property.
relative_property ::= PROPERTY(P) NUMBER(I) NUMBER(J) SEMICOLON.
{
   if (!strcmp(P->text, "offset:"))
     {
        if (strchr(I->text, '.') || (!edje_parser_strtol(I->text, &REL->offset[0])))
          ERROR_RANGE(I);
        else if (strchr(J->text, '.') || (!edje_parser_strtol(J->text, &REL->offset[1])))
          ERROR_RANGE(J);
     }
   else if (!strcmp(P->text, "relative:"))
     {
        if (!edje_parser_strtod(I->text, &REL->relative[0]))
          ERROR_RANGE(I);
        else if (!edje_parser_strtod(J->text, &REL->relative[1]))
          ERROR_RANGE(J);
     }
   else ERROR_SYNTAX(P);
   
   edje_parser_token_free(P);
   edje_parser_token_free(I);
   edje_parser_token_free(J);
}
relative_property ::= PROPERTY(P) ID(I) SEMICOLON.
{
   if (!strcmp(P->text, "to:"))
     STRINGSHARE_REPLACE_NOQUOTES(REL->to, I->text);
   else if (!strcmp(P->text, "to_x:"))
     STRINGSHARE_REPLACE_NOQUOTES(REL->to_x, I->text);
   else if (!strcmp(P->text, "to_y:"))
     STRINGSHARE_REPLACE_NOQUOTES(REL->to_y, I->text);
   else ERROR_SYNTAX(P);
   edje_parser_token_free(P);
   edje_parser_token_free(I);
}
/******************************* END DESC SUB-BLOCKS ****************************/
/************************** END DESCRIPTION CODE ********************************/
/************************** START PART PROPERTY CODE ****************************/
part_subblock ::= part_property.
part_property ::= PROPERTY(P) ID(I) SEMICOLON.
{
   Edje_Part *p;

   p = PARSER_CURRENT(PART, Edje_Part);
   DBG("Part property - '%s':'%s'", P->text, I->text);
#define EDJE_PART_CHECK(TYPE) \
if (!strcmp(P->text, #TYPE":")) \
  STRINGSHARE_REPLACE_NOQUOTES(p->TYPE, I->text)
  
   EDJE_PART_CHECK(clip_to);
   else EDJE_PART_CHECK(name);
   else EDJE_PART_CHECK(source);
   else EDJE_PART_CHECK(source2);
   else EDJE_PART_CHECK(source3);
   else EDJE_PART_CHECK(source4);
   else EDJE_PART_CHECK(source5);
   else EDJE_PART_CHECK(source6);
   else ERROR_SYNTAX(P);
#undef EDJE_PART_CHECK
   edje_parser_token_free(P);
   edje_parser_token_free(I);
}
part_property ::= PROPERTY(P) CAPS(C) SEMICOLON.
{
   Edje_Part *p;

   p = PARSER_CURRENT(PART, Edje_Part);
   DBG("Part property - '%s':'%s'", P->text, C->text);
   if (!strcmp(P->text, "type:"))
     {
#define EDJE_PART_CHECK(TYPE) \
if (!strcmp(C->text, #TYPE)) \
  p->type = EDJE_PART_TYPE_##TYPE

        EDJE_PART_CHECK(RECT);
        else EDJE_PART_CHECK(TEXT);
        else EDJE_PART_CHECK(IMAGE);
        else EDJE_PART_CHECK(SWALLOW);
        else EDJE_PART_CHECK(TEXTBLOCK);
        else EDJE_PART_CHECK(GROUP);
        else EDJE_PART_CHECK(BOX);
        else EDJE_PART_CHECK(TABLE);
        else EDJE_PART_CHECK(EXTERNAL);
        else ERROR_SYNTAX(C);
#undef EDJE_PART_CHECK
     }
   else if (!strcmp(P->text, "ignore_flags:"))
     {
        if (!strcmp(C->text, "NONE"))
          p->ignore_flags = EDJE_IGNORE_FLAG_NONE;
        else if (!strcmp(C->text, "ON_HOLD"))
          p->ignore_flags = EDJE_IGNORE_FLAG_ON_HOLD;
        else
          ERROR_SYNTAX(C);
     }
   else if (!strcmp(P->text, "pointer_mode:"))
     {
        if (!strcmp(C->text, "AUTOGRAB"))
          p->pointer_mode = EDJE_POINTER_MODE_AUTOGRAB;
        else if (!strcmp(C->text, "NOGRAB"))
          p->pointer_mode = EDJE_POINTER_MODE_NOGRAB;
        else
          ERROR_SYNTAX(C);
     }
   else if (!strcmp(P->text, "effect:"))
     {
#define EDJE_PART_CHECK(TYPE) \
if (!strcmp(C->text, #TYPE)) \
  p->effect = EDJE_PART_EFFECT_##TYPE

        EDJE_PART_CHECK(PLAIN);
        else EDJE_PART_CHECK(OUTLINE);
        else EDJE_PART_CHECK(SOFT_OUTLINE);
        else EDJE_PART_CHECK(SHADOW);
        else EDJE_PART_CHECK(SOFT_SHADOW);
        else EDJE_PART_CHECK(OUTLINE_SHADOW);
        else EDJE_PART_CHECK(OUTLINE_SOFT_SHADOW);
        else EDJE_PART_CHECK(FAR_SHADOW);
        else EDJE_PART_CHECK(FAR_SOFT_SHADOW);
        else EDJE_PART_CHECK(GLOW);
        else ERROR_SYNTAX(C);
#undef EDJE_PART_CHECK
     }
   else if (!strcmp(P->text, "entry_mode:"))
     {
#define EDJE_PART_CHECK(TYPE) \
if (!strcmp(C->text, #TYPE)) \
  p->entry_mode = EDJE_PART_ENTRY_MODE_##TYPE

        EDJE_PART_CHECK(NONE);
        else EDJE_PART_CHECK(PLAIN);
        else EDJE_PART_CHECK(EDITABLE);
        else EDJE_PART_CHECK(PASSWORD);
        else ERROR_SYNTAX(C);
#undef EDJE_PART_CHECK
     }
   else if (!strcmp(P->text, "select_mode:"))
     {
        if (!strcmp(C->text, "DEFAULT"))
          p->select_mode = EDJE_PART_SELECT_MODE_DEFAULT;
        else if (!strcmp(C->text, "EXPLICIT_DEFAULT"))
          p->select_mode = EDJE_PART_SELECT_MODE_EXPLICIT_DEFAULT;
        else
          ERROR_SYNTAX(C);
     }
   else
     ERROR_SYNTAX(P);
   edje_parser_token_free(P);
   edje_parser_token_free(C);
}
part_property ::= PROPERTY(P) NUMBER(I) SEMICOLON.
{
   Edje_Part *p;
   int i;

   p = PARSER_CURRENT(PART, Edje_Part);
   DBG("Part property - '%s':'%s'", P->text, I->text);

   if (!edje_parser_strtobool(I->text, &i))
     {
        ERROR_RANGE(I);
        goto part_property_bool_out;
     }
#define EDJE_PART_CHECK(TYPE) \
if (!strcmp(P->text, #TYPE":")) \
  p->TYPE = !!i

   EDJE_PART_CHECK(mouse_events);
   else EDJE_PART_CHECK(repeat_events);
   else EDJE_PART_CHECK(scale);
   else EDJE_PART_CHECK(precise_is_inside);
   else EDJE_PART_CHECK(use_alternate_font_metrics);
   else EDJE_PART_CHECK(multiline);
   else ERROR_SYNTAX(P);

#undef EDJE_PART_CHECK

part_property_bool_out:
   edje_parser_token_free(P);
   edje_parser_token_free(I);
}
/*************************** END PART PROPERTY CODE ****************************/
/*************************** END PART SUB-BLOCKS *******************************/
/******************************* END PART CODE *********************************/
